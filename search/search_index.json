{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This documentation covers the Subject Interface v1, an open protocol for communication between Cooperative Intelligent Transportation System (C-ITS) participants.</p> <p>TLC Terminology</p> <p>The interface originally served Traffic Light Controllers (TLCs), and this legacy terminology persists in the API specifications for backward compatibility. \"TLC\" now refers to any connected entity: traffic controllers, sensors, barriers, displays, or any C-ITS participant. See Terminology Reference for the mapping between legacy and generic terminology.</p>"},{"location":"#what-is-the-subject-interface","title":"What is the Subject Interface?","text":"<p>The Subject Interface defines a vendor-neutral, license-free communication protocol for interoperability across C-ITS ecosystems. It provides data exchange between roadside devices, central systems, and service providers through a dual-layer architecture:</p> <ul> <li>JSON-REST API Layer - Administrative control and lifecycle management</li> <li>TCP Streaming Protocol Layer - Low latency data exchange</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Low latency communication for C-ITS applications</li> <li>Bidirectional data exchange with continuous asynchronous streaming</li> <li>Message-agnostic architecture supporting any payload type</li> <li>Role-based access control with security framework</li> <li>Horizontal scaling support for distributed deployments</li> </ul>"},{"location":"#introduction-contents","title":"Introduction Contents","text":""},{"location":"#communication-patterns","title":"Communication Patterns","text":"<p>Roadside-to-central and central-to-central communication patterns, supported entity types, and system topology.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<p>This documentation is organized into main chapters:</p>"},{"location":"#architecture","title":"Architecture","text":"<p>System architecture, components, security framework, and role-based access control.</p>"},{"location":"#rest-api","title":"REST API","text":"<p>JSON-REST API reference including session management, registration, and token operations.</p>"},{"location":"#tcp-streaming-protocol","title":"TCP Streaming Protocol","text":"<p>Technical specifications for the streaming protocol including datagram types and connection management.</p>"},{"location":"#example","title":"Example","text":"<p>Complete implementation walkthrough demonstrating both API and streaming protocol usage.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For system integrators and developers new to the Subject Interface:</p> <ol> <li>Review this introduction to understand the interface and communication patterns</li> <li>Study Architecture for system architecture, security, and access model</li> <li>Implement using REST API and TCP Streaming Protocol specifications</li> <li>See Example for a complete implementation walkthrough</li> </ol>"},{"location":"api-reference/","title":"OpenAPI specification","text":"<p>The complete OpenAPI 3.0.3 specification can be downloaded here.</p>"},{"location":"api-reference/#subject-interface-rest-api-operational-100","title":"Subject Interface REST API (Operational) 1.0.0","text":"<p>Operational REST API for managing sessions, TLCs (Subjects), and related resources.</p> <p>This is a down scoped version of the full API, focused on operational roles and excluding platform administration capabilities.</p>"},{"location":"api-reference/#authentication","title":"Authentication","text":"<p>All endpoints require custom header authentication using X-Authorization header. Tokens are managed through the Authorization Token endpoints.</p>"},{"location":"api-reference/#authorization-roles-operational","title":"Authorization Roles (Operational)","text":"<ul> <li>TLC Admin/System/Analyst: TLC management and analysis</li> <li>Broker Admin/System/Analyst: Broker operations</li> <li>Monitor Admin/System: Monitoring capabilities</li> </ul>"},{"location":"api-reference/#authorizations","title":"Authorizations","text":""},{"location":"api-reference/#get-v1authorizations","title":"GET /v1/authorizations","text":"<p>List authorizations</p> Description <p>Retrieve authorizations with optional filtering.</p> <p>Results are automatically filtered based on the domain and account associated with the API key's authorization.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <p> Response 200 OK </p> application/json <p><pre><code>[\n    {\n        \"uuid\": \"30a4b265-d817-493d-ad08-11228b48f93c\",\n        \"domain\": \"string\",\n        \"account\": \"4cd52e90-5079-40c9-a36d-719dee0226ff\",\n        \"role\": \"string\",\n        \"tlcIdentifiers\": [\n            \"string\"\n        ]\n    }\n]\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"#/components/schemas/ResponseAuthorization\"\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#post-v1authorizations","title":"POST /v1/authorizations","text":"<p>Create authorization</p> Description <p>Create a new authorization.</p> <p>The domain and account are automatically set based on the API key's authorization context.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <p>Request body</p> application/json <p><pre><code>{\n    \"role\": \"TLC_ADMIN\",\n    \"tlcIdentifiers\": [\n        \"string\"\n    ]\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the request body <pre><code>{\n    \"type\": \"object\",\n    \"required\": [\n        \"role\"\n    ],\n    \"properties\": {\n        \"role\": {\n            \"$ref\": \"#/components/schemas/AuthorizationRole\"\n        },\n        \"tlcIdentifiers\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\",\n                \"pattern\": \"^[a-z0-9_-]{8}$\"\n            },\n            \"description\": \"TLC identifiers (8 chars, lowercase alphanumeric, underscore, hyphen)\"\n        }\n    }\n}\n</code></pre> <p> Response 201 Created </p> application/json <p><pre><code>{\n    \"uuid\": \"efdaf179-aa41-4d56-bfe9-3906ff2d2d97\",\n    \"domain\": \"string\",\n    \"account\": \"d95455a1-301b-4b7e-b18b-957e3c637bee\",\n    \"role\": \"string\",\n    \"tlcIdentifiers\": [\n        \"string\"\n    ]\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"account\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"role\": {\n            \"type\": \"string\"\n        },\n        \"tlcIdentifiers\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\"\n            }\n        }\n    }\n}\n</code></pre> <p> Response 400 Bad Request </p> <p>Refer to the common response description: BadRequest.</p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#get-v1authorizationsuuid","title":"GET /v1/authorizations/{uuid}","text":"<p>Get authorization by UUID</p> Description <p>Retrieve a specific authorization.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>uuid</code> path string No Resource UUID <p> Response 200 OK </p> application/json <p><pre><code>{\n    \"uuid\": \"9c2f7d11-51b0-46eb-8d03-835f89785dc1\",\n    \"domain\": \"string\",\n    \"account\": \"0251c9cf-5d21-4831-9a36-8e73b8271c8c\",\n    \"role\": \"string\",\n    \"tlcIdentifiers\": [\n        \"string\"\n    ]\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"account\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"role\": {\n            \"type\": \"string\"\n        },\n        \"tlcIdentifiers\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\"\n            }\n        }\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#put-v1authorizationsuuid","title":"PUT /v1/authorizations/{uuid}","text":"<p>Update authorization</p> Description <p>Update an existing authorization.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>uuid</code> path string No Resource UUID <p>Request body</p> application/json <p><pre><code>{\n    \"role\": \"TLC_ADMIN\",\n    \"tlcIdentifiers\": [\n        \"string\"\n    ]\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the request body <pre><code>{\n    \"type\": \"object\",\n    \"required\": [\n        \"role\"\n    ],\n    \"properties\": {\n        \"role\": {\n            \"$ref\": \"#/components/schemas/AuthorizationRole\"\n        },\n        \"tlcIdentifiers\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\",\n                \"pattern\": \"^[a-z0-9_-]{8}$\"\n            },\n            \"description\": \"TLC identifiers (8 chars, lowercase alphanumeric, underscore, hyphen)\"\n        }\n    }\n}\n</code></pre> <p> Response 200 OK </p> application/json <p><pre><code>{\n    \"uuid\": \"5408f6ae-11f6-4761-a356-4a3cf20864f9\",\n    \"domain\": \"string\",\n    \"account\": \"4f8682c9-75e2-4050-bca8-e1269f899a7a\",\n    \"role\": \"string\",\n    \"tlcIdentifiers\": [\n        \"string\"\n    ]\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"account\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"role\": {\n            \"type\": \"string\"\n        },\n        \"tlcIdentifiers\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\"\n            }\n        }\n    }\n}\n</code></pre> <p> Response 400 Bad Request </p> <p>Refer to the common response description: BadRequest.</p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#delete-v1authorizationsuuid","title":"DELETE /v1/authorizations/{uuid}","text":"<p>Delete authorization</p> Description <p>Delete an authorization.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>uuid</code> path string No Resource UUID <p> Response 204 No Content </p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#authorization-tokens","title":"Authorization Tokens","text":""},{"location":"api-reference/#get-v1authorizationtokens","title":"GET /v1/authorizationtokens","text":"<p>List authorization tokens</p> Description <p>Retrieve authorization tokens with optional filtering.</p> <p>Results are automatically filtered based on the domain and account associated with the API key's authorization.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>authorization</code> query string No Filter by authorization UUID <p> Response 200 OK </p> application/json <p><pre><code>[\n    {\n        \"uuid\": \"0309c90e-a35c-44d5-a8f1-bde3d2bd46ae\",\n        \"token\": \"string\",\n        \"authorization\": \"11ade789-52be-42a4-a426-31eb0630ffd5\"\n    }\n]\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"#/components/schemas/ResponseAuthorizationToken\"\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#post-v1authorizationtokens","title":"POST /v1/authorizationtokens","text":"<p>Create authorization token</p> Description <p>Generate a new authorization token.</p> <p>The token is automatically associated with the domain and account from the API key's authorization context.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <p>Request body</p> application/json <p><pre><code>{\n    \"authorization\": \"4101f614-3e87-40af-8296-2731ba79b100\"\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the request body <pre><code>{\n    \"type\": \"object\",\n    \"required\": [\n        \"authorization\"\n    ],\n    \"properties\": {\n        \"authorization\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Authorization UUID\"\n        }\n    }\n}\n</code></pre> <p> Response 201 Created </p> application/json <p><pre><code>{\n    \"uuid\": \"86b8726a-da3d-4a62-ac84-fc1f5bf9076a\",\n    \"token\": \"string\",\n    \"authorization\": \"2f3b2583-25d7-4c15-b1fa-3495ccbbb0df\"\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9+/]{42}[A-Za-z0-9+/=]$\",\n            \"description\": \"Custom authorization token value (Base64 string)\"\n        },\n        \"authorization\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Authorization UUID\"\n        }\n    }\n}\n</code></pre> <p> Response 400 Bad Request </p> <p>Refer to the common response description: BadRequest.</p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#get-v1authorizationtokensuuid","title":"GET /v1/authorizationtokens/{uuid}","text":"<p>Get authorization token by UUID</p> Description <p>Retrieve a specific authorization token.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>uuid</code> path string No Resource UUID <p> Response 200 OK </p> application/json <p><pre><code>{\n    \"uuid\": \"f634385d-9cb8-402b-9aaa-5068cf5a86d1\",\n    \"token\": \"string\",\n    \"authorization\": \"a0447bcd-507e-4270-a2e3-95a50be6c7ff\"\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9+/]{42}[A-Za-z0-9+/=]$\",\n            \"description\": \"Custom authorization token value (Base64 string)\"\n        },\n        \"authorization\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Authorization UUID\"\n        }\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#put-v1authorizationtokensuuid","title":"PUT /v1/authorizationtokens/{uuid}","text":"<p>Update authorization token</p> Description <p>Update an existing authorization token.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>uuid</code> path string No Resource UUID <p>Request body</p> application/json <p><pre><code>{\n    \"authorization\": \"f89332ed-700e-42a4-9c66-643eb9db1b99\"\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the request body <pre><code>{\n    \"type\": \"object\",\n    \"required\": [\n        \"authorization\"\n    ],\n    \"properties\": {\n        \"authorization\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Authorization UUID\"\n        }\n    }\n}\n</code></pre> <p> Response 200 OK </p> application/json <p><pre><code>{\n    \"uuid\": \"b4a45410-597b-4d26-af7e-c6aaf09429ab\",\n    \"token\": \"string\",\n    \"authorization\": \"0e1545e6-8feb-40c0-b6a3-2776325f359c\"\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9+/]{42}[A-Za-z0-9+/=]$\",\n            \"description\": \"Custom authorization token value (Base64 string)\"\n        },\n        \"authorization\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Authorization UUID\"\n        }\n    }\n}\n</code></pre> <p> Response 400 Bad Request </p> <p>Refer to the common response description: BadRequest.</p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#delete-v1authorizationtokensuuid","title":"DELETE /v1/authorizationtokens/{uuid}","text":"<p>Delete authorization token</p> Description <p>Revoke an authorization token.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>uuid</code> path string No Resource UUID <p> Response 204 No Content </p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#tlcs","title":"TLCs","text":""},{"location":"api-reference/#get-v1tlcs","title":"GET /v1/tlcs","text":"<p>List TLCs</p> Description <p>Retrieve TLCs with optional filtering.</p> <p>Results are automatically filtered based on the domain and account associated with the API key's authorization.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin, TLC Analyst</li> <li>Broker Admin, Broker System, Broker Analyst</li> <li>Monitor Admin, Monitor System</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <p> Response 200 OK </p> application/json <p><pre><code>[\n    {\n        \"uuid\": \"472d3514-daa4-44ea-a937-45ddf61556f1\",\n        \"identifier\": \"string\",\n        \"domain\": \"string\",\n        \"account\": \"7addc6d1-bd90-42a2-95e5-10d404d788db\",\n        \"type\": \"TCPStreaming\"\n    }\n]\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"#/components/schemas/ResponseTlc\"\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#post-v1tlcs","title":"POST /v1/tlcs","text":"<p>Create TLC</p> Description <p>Create a new Traffic Light Controller.</p> <p>The domain, account, and type are automatically set based on the API key's authorization context.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <p>Request body</p> application/json <p><pre><code>{\n    \"identifier\": \"string\"\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the request body <pre><code>{\n    \"type\": \"object\",\n    \"required\": [\n        \"identifier\"\n    ],\n    \"properties\": {\n        \"identifier\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[a-z0-9_-]{8}$\",\n            \"description\": \"TLC identifier (8 chars, lowercase alphanumeric, underscore, hyphen)\"\n        }\n    }\n}\n</code></pre> <p> Response 201 Created </p> application/json <p><pre><code>{\n    \"uuid\": \"e62bf22b-8cd3-4efb-8044-8e8c449b28ea\",\n    \"identifier\": \"string\",\n    \"domain\": \"string\",\n    \"account\": \"777d8dbc-9ac9-4a7a-9a16-4c31b30fc101\",\n    \"type\": \"TCPStreaming\"\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"identifier\": {\n            \"type\": \"string\"\n        },\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"account\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"type\": {\n            \"$ref\": \"#/components/schemas/TlcType\"\n        }\n    }\n}\n</code></pre> <p> Response 400 Bad Request </p> <p>Refer to the common response description: BadRequest.</p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#get-v1tlcsuuid","title":"GET /v1/tlcs/{uuid}","text":"<p>Get TLC by UUID</p> Description <p>Retrieve a specific TLC.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin, TLC Analyst</li> <li>Broker Admin, Broker System, Broker Analyst</li> <li>Monitor Admin, Monitor System</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>uuid</code> path string No Resource UUID <p> Response 200 OK </p> application/json <p><pre><code>{\n    \"uuid\": \"39290e77-f46b-48d2-8a99-0e3c2d55e094\",\n    \"identifier\": \"string\",\n    \"domain\": \"string\",\n    \"account\": \"05cc9165-84aa-4994-852f-fbcd83ec9783\",\n    \"type\": \"TCPStreaming\"\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"identifier\": {\n            \"type\": \"string\"\n        },\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"account\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n        },\n        \"type\": {\n            \"$ref\": \"#/components/schemas/TlcType\"\n        }\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#delete-v1tlcsuuid","title":"DELETE /v1/tlcs/{uuid}","text":"<p>Delete TLC</p> Description <p>Delete a TLC.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>uuid</code> path string No Resource UUID <p> Response 204 No Content </p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#sessions","title":"Sessions","text":""},{"location":"api-reference/#get-v1sessions","title":"GET /v1/sessions","text":"<p>List active sessions</p> Description <p>Retrieve active sessions with optional filtering.</p> <p>Results are automatically filtered based on the domain associated with the API key's authorization.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin, TLC System</li> <li>Broker Admin, Broker System</li> <li>Monitor Admin, Monitor System</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>protocol</code> query None No Filter by session protocol <code>type</code> query None No Filter by session type <p> Response 200 OK </p> application/json <p><pre><code>[\n    {\n        \"domain\": \"string\",\n        \"type\": \"TLC\",\n        \"token\": \"string\",\n        \"protocol\": \"TCPStreaming_Singleplex\",\n        \"details\": null\n    }\n]\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"#/components/schemas/ResponseSession\"\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#post-v1sessions","title":"POST /v1/sessions","text":"<p>Create session</p> Description <p>Create a new streaming session.</p> <p>The domain in the request must match the domain associated with the API key's authorization.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin, TLC System</li> <li>Broker Admin, Broker System</li> <li>Monitor Admin, Monitor System</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <p>Request body</p> application/json <p><pre><code>{\n    \"domain\": \"string\",\n    \"type\": \"TLC\",\n    \"protocol\": \"TCPStreaming_Singleplex\",\n    \"details\": null\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the request body <pre><code>{\n    \"type\": \"object\",\n    \"required\": [\n        \"domain\",\n        \"type\",\n        \"protocol\",\n        \"details\"\n    ],\n    \"properties\": {\n        \"domain\": {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"description\": \"Domain name (converted to lowercase)\"\n        },\n        \"type\": {\n            \"$ref\": \"#/components/schemas/SessionType\"\n        },\n        \"protocol\": {\n            \"$ref\": \"#/components/schemas/SessionProtocol\"\n        },\n        \"details\": {\n            \"oneOf\": [\n                {\n                    \"$ref\": \"#/components/schemas/RequestTCPStreamingSingleplexSessionDetails\"\n                },\n                {\n                    \"$ref\": \"#/components/schemas/RequestTCPStreamingMultiplexSessionDetails\"\n                }\n            ],\n            \"discriminator\": {\n                \"propertyName\": \"protocol\"\n            }\n        }\n    }\n}\n</code></pre> <p> Response 201 Created </p> application/json <p><pre><code>{\n    \"domain\": \"string\",\n    \"type\": \"TLC\",\n    \"token\": \"string\",\n    \"protocol\": \"TCPStreaming_Singleplex\",\n    \"details\": null\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"type\": {\n            \"$ref\": \"#/components/schemas/SessionType\"\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"description\": \"Session token\"\n        },\n        \"protocol\": {\n            \"$ref\": \"#/components/schemas/SessionProtocol\"\n        },\n        \"details\": {\n            \"oneOf\": [\n                {\n                    \"$ref\": \"#/components/schemas/ResponseTCPStreamingSingleplexSessionDetails\"\n                },\n                {\n                    \"$ref\": \"#/components/schemas/ResponseTCPStreamingMultiplexSessionDetails\"\n                }\n            ],\n            \"discriminator\": {\n                \"propertyName\": \"protocol\"\n            }\n        }\n    }\n}\n</code></pre> <p> Response 400 Bad Request </p> <p>Refer to the common response description: BadRequest.</p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#get-v1sessionstoken","title":"GET /v1/sessions/{token}","text":"<p>Get session by token</p> Description <p>Retrieve a specific session.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin, TLC System</li> <li>Broker Admin, Broker System</li> <li>Monitor Admin, Monitor System</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>token</code> path string No Session token <p> Response 200 OK </p> application/json <p><pre><code>{\n    \"domain\": \"string\",\n    \"type\": \"TLC\",\n    \"token\": \"string\",\n    \"protocol\": \"TCPStreaming_Singleplex\",\n    \"details\": null\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"type\": {\n            \"$ref\": \"#/components/schemas/SessionType\"\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"description\": \"Session token\"\n        },\n        \"protocol\": {\n            \"$ref\": \"#/components/schemas/SessionProtocol\"\n        },\n        \"details\": {\n            \"oneOf\": [\n                {\n                    \"$ref\": \"#/components/schemas/ResponseTCPStreamingSingleplexSessionDetails\"\n                },\n                {\n                    \"$ref\": \"#/components/schemas/ResponseTCPStreamingMultiplexSessionDetails\"\n                }\n            ],\n            \"discriminator\": {\n                \"propertyName\": \"protocol\"\n            }\n        }\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#put-v1sessionstoken","title":"PUT /v1/sessions/{token}","text":"<p>Update session</p> Description <p>Update session (TCP Streaming Multiplex only).</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin, TLC System</li> <li>Broker Admin, Broker System</li> <li>Monitor Admin, Monitor System</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>token</code> path string No Session token <p>Request body</p> application/json <p><pre><code>{\n    \"securityMode\": \"NONE\",\n    \"tlcIdentifiers\": [\n        \"string\"\n    ]\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the request body <pre><code>{\n    \"type\": \"object\",\n    \"required\": [\n        \"securityMode\"\n    ],\n    \"properties\": {\n        \"securityMode\": {\n            \"$ref\": \"#/components/schemas/SecurityMode\"\n        },\n        \"tlcIdentifiers\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\",\n                \"pattern\": \"^[a-z0-9_-]{8}$\"\n            },\n            \"description\": \"TLC identifiers (8 chars each, lowercase alphanumeric, underscore, hyphen)\"\n        }\n    }\n}\n</code></pre> <p> Response 200 OK </p> application/json <p><pre><code>{\n    \"domain\": \"string\",\n    \"type\": \"TLC\",\n    \"token\": \"string\",\n    \"protocol\": \"TCPStreaming_Singleplex\",\n    \"details\": null\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"type\": {\n            \"$ref\": \"#/components/schemas/SessionType\"\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"description\": \"Session token\"\n        },\n        \"protocol\": {\n            \"$ref\": \"#/components/schemas/SessionProtocol\"\n        },\n        \"details\": {\n            \"oneOf\": [\n                {\n                    \"$ref\": \"#/components/schemas/ResponseTCPStreamingSingleplexSessionDetails\"\n                },\n                {\n                    \"$ref\": \"#/components/schemas/ResponseTCPStreamingMultiplexSessionDetails\"\n                }\n            ],\n            \"discriminator\": {\n                \"propertyName\": \"protocol\"\n            }\n        }\n    }\n}\n</code></pre> <p> Response 400 Bad Request </p> <p>Refer to the common response description: BadRequest.</p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#delete-v1sessionstoken","title":"DELETE /v1/sessions/{token}","text":"<p>End session</p> Description <p>Terminate an active session.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin</li> <li>Broker Admin</li> <li>Monitor Admin</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>token</code> path string No Session token <p> Response 204 No Content </p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#session-logs","title":"Session Logs","text":""},{"location":"api-reference/#get-v1sessionlogs","title":"GET /v1/sessionlogs","text":"<p>List session logs</p> Description <p>Retrieve session logs within a time range.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin, TLC Analyst</li> <li>Broker Admin, Broker Analyst</li> <li>Monitor Admin, Monitor System</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>from</code> query string No Start time (ISO8601 format) <code>until</code> query string No End time (ISO8601 format) <p> Response 200 OK </p> application/json <p><pre><code>[\n    {\n        \"token\": \"string\",\n        \"domain\": \"string\",\n        \"account\": \"string\",\n        \"type\": \"string\",\n        \"protocol\": \"string\",\n        \"details\": \"string\",\n        \"created\": 54,\n        \"connected\": 190,\n        \"remoteAddress\": \"string\",\n        \"ended\": 249,\n        \"endReason\": \"string\",\n        \"tlcScopeHistory\": [\n            {\n                \"timestamp\": 44,\n                \"scope\": \"string\",\n                \"tlcIdentifier\": \"string\"\n            }\n        ]\n    }\n]\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"#/components/schemas/ResponseSessionLog\"\n    }\n}\n</code></pre> <p> Response 400 Bad Request </p> <p>Refer to the common response description: BadRequest.</p> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p>"},{"location":"api-reference/#get-v1sessionlogstoken","title":"GET /v1/sessionlogs/{token}","text":"<p>Get session log by token</p> Description <p>Retrieve a specific session log.</p> <p>Authorization: Requires one of these roles:</p> <ul> <li>TLC Admin, TLC Analyst</li> <li>Broker Admin, Broker Analyst</li> <li>Monitor Admin, Monitor System</li> </ul> <p>Input parameters</p> Parameter In Type Default Nullable Description <code>X-Authorization</code> header string N/A No Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints. <code>token</code> path string No Session token <p> Response 200 OK </p> application/json <p><pre><code>{\n    \"token\": \"string\",\n    \"domain\": \"string\",\n    \"account\": \"string\",\n    \"type\": \"string\",\n    \"protocol\": \"string\",\n    \"details\": \"string\",\n    \"created\": 184,\n    \"connected\": 123,\n    \"remoteAddress\": \"string\",\n    \"ended\": 230,\n    \"endReason\": \"string\",\n    \"tlcScopeHistory\": [\n        {\n            \"timestamp\": 13,\n            \"scope\": \"string\",\n            \"tlcIdentifier\": \"string\"\n        }\n    ]\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"token\": {\n            \"type\": \"string\",\n            \"description\": \"Session token\"\n        },\n        \"domain\": {\n            \"type\": \"string\"\n        },\n        \"account\": {\n            \"type\": \"string\"\n        },\n        \"type\": {\n            \"type\": \"string\"\n        },\n        \"protocol\": {\n            \"type\": \"string\"\n        },\n        \"details\": {\n            \"type\": \"string\",\n            \"description\": \"Session details as JSON string\"\n        },\n        \"created\": {\n            \"type\": \"integer\",\n            \"format\": \"int64\",\n            \"description\": \"Creation timestamp (Unix epoch milliseconds)\"\n        },\n        \"connected\": {\n            \"type\": \"integer\",\n            \"format\": \"int64\",\n            \"description\": \"Connection timestamp (Unix epoch milliseconds)\"\n        },\n        \"remoteAddress\": {\n            \"type\": \"string\",\n            \"description\": \"Remote IP address\"\n        },\n        \"ended\": {\n            \"type\": \"integer\",\n            \"format\": \"int64\",\n            \"description\": \"End timestamp (Unix epoch milliseconds)\"\n        },\n        \"endReason\": {\n            \"type\": \"string\",\n            \"description\": \"Reason for session termination\"\n        },\n        \"tlcScopeHistory\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ResponseSessionTlcLog\"\n            }\n        }\n    }\n}\n</code></pre> <p> Response 401 Unauthorized </p> <p>Refer to the common response description: Unauthorized.</p> <p> Response 403 Forbidden </p> <p>Refer to the common response description: Forbidden.</p> <p> Response 404 Not Found </p> <p>Refer to the common response description: NotFound.</p>"},{"location":"api-reference/#schemas","title":"Schemas","text":""},{"location":"api-reference/#authorizationrole","title":"AuthorizationRole","text":"<p>Type: string</p>"},{"location":"api-reference/#direction","title":"Direction","text":"<p>Type: string</p>"},{"location":"api-reference/#errorresponse","title":"ErrorResponse","text":"Name Type <code>message</code> string <code>status</code> integer"},{"location":"api-reference/#requestauthorization","title":"RequestAuthorization","text":"Name Type <code>role</code> AuthorizationRole <code>tlcIdentifiers</code> Array&lt;string&gt;"},{"location":"api-reference/#requestauthorizationtoken","title":"RequestAuthorizationToken","text":"Name Type <code>authorization</code> string(uuid)"},{"location":"api-reference/#requestsession","title":"RequestSession","text":"Name Type <code>details</code> <code>domain</code> string <code>protocol</code> SessionProtocol <code>type</code> SessionType"},{"location":"api-reference/#requesttcpstreamingmultiplexsessiondetails","title":"RequestTCPStreamingMultiplexSessionDetails","text":"Name Type <code>securityMode</code> SecurityMode <code>tlcIdentifiers</code> Array&lt;string&gt;"},{"location":"api-reference/#requesttcpstreamingsingleplexsessiondetails","title":"RequestTCPStreamingSingleplexSessionDetails","text":"Name Type <code>securityMode</code> SecurityMode <code>tlcIdentifier</code> string"},{"location":"api-reference/#requesttlc","title":"RequestTlc","text":"Name Type <code>identifier</code> string"},{"location":"api-reference/#responseauthorization","title":"ResponseAuthorization","text":"Name Type <code>account</code> string(uuid) <code>domain</code> string <code>role</code> string <code>tlcIdentifiers</code> Array&lt;string&gt; <code>uuid</code> string(uuid)"},{"location":"api-reference/#responseauthorizationtoken","title":"ResponseAuthorizationToken","text":"Name Type <code>authorization</code> string(uuid) <code>token</code> string <code>uuid</code> string(uuid)"},{"location":"api-reference/#responsesession","title":"ResponseSession","text":"Name Type <code>details</code> <code>domain</code> string <code>protocol</code> SessionProtocol <code>token</code> string <code>type</code> SessionType"},{"location":"api-reference/#responsesessiondetailsconnectioninitiation","title":"ResponseSessionDetailsConnectionInitiation","text":"Name Type <code>expiration</code> string(date-time) <code>host</code> string <code>port</code> integer"},{"location":"api-reference/#responsesessionlog","title":"ResponseSessionLog","text":"Name Type <code>account</code> string <code>connected</code> integer(int64) <code>created</code> integer(int64) <code>details</code> string <code>domain</code> string <code>ended</code> integer(int64) <code>endReason</code> string <code>protocol</code> string <code>remoteAddress</code> string <code>tlcScopeHistory</code> Array&lt;ResponseSessionTlcLog&gt; <code>token</code> string <code>type</code> string"},{"location":"api-reference/#responsesessiontlclog","title":"ResponseSessionTlcLog","text":"Name Type <code>scope</code> string <code>timestamp</code> integer(int64) <code>tlcIdentifier</code> string"},{"location":"api-reference/#responsetcpstreamingmultiplexsessiondetails","title":"ResponseTCPStreamingMultiplexSessionDetails","text":"Name Type <code>clockDiffLimit</code> string <code>clockDiffLimitDuration</code> string <code>keepAliveTimeout</code> string <code>listener</code> ResponseSessionDetailsConnectionInitiation <code>payloadRateLimit</code> integer <code>payloadRateLimitDuration</code> string <code>payloadThroughputLimit</code> integer <code>payloadThroughputLimitDuration</code> string <code>securityMode</code> SecurityMode <code>tlcIdentifiers</code> Array&lt;string&gt;"},{"location":"api-reference/#responsetcpstreamingsingleplexsessiondetails","title":"ResponseTCPStreamingSingleplexSessionDetails","text":"Name Type <code>clockDiffLimit</code> string <code>clockDiffLimitDuration</code> string <code>keepAliveTimeout</code> string <code>listener</code> ResponseSessionDetailsConnectionInitiation <code>payloadRateLimit</code> integer <code>payloadRateLimitDuration</code> string <code>payloadThroughputLimit</code> integer <code>payloadThroughputLimitDuration</code> string <code>securityMode</code> SecurityMode <code>tlcIdentifier</code> string"},{"location":"api-reference/#responsetlc","title":"ResponseTlc","text":"Name Type <code>account</code> string(uuid) <code>domain</code> string <code>identifier</code> string <code>type</code> TlcType <code>uuid</code> string(uuid)"},{"location":"api-reference/#securitymode","title":"SecurityMode","text":"<p>Type: string</p>"},{"location":"api-reference/#sessionprotocol","title":"SessionProtocol","text":"<p>Type: string</p>"},{"location":"api-reference/#sessiontype","title":"SessionType","text":"<p>Type: string</p>"},{"location":"api-reference/#tlctype","title":"TlcType","text":"<p>Type: string</p>"},{"location":"api-reference/#common-responses","title":"Common responses","text":"<p>This section describes common responses that are reused across operations.</p>"},{"location":"api-reference/#badrequest","title":"BadRequest","text":"<p>Bad request - Invalid input</p> <p></p> application/json <p><pre><code>{\n    \"message\": \"string\",\n    \"status\": 0\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"message\": {\n            \"type\": \"string\",\n            \"description\": \"Error message (e.g., \\\"HTTP 401 Unauthorized\\\")\"\n        },\n        \"status\": {\n            \"type\": \"integer\",\n            \"description\": \"HTTP status code\"\n        }\n    }\n}\n</code></pre>"},{"location":"api-reference/#unauthorized","title":"Unauthorized","text":"<p>Unauthorized - Authentication required</p> <p></p> application/json <p><pre><code>{\n    \"message\": \"string\",\n    \"status\": 0\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"message\": {\n            \"type\": \"string\",\n            \"description\": \"Error message (e.g., \\\"HTTP 401 Unauthorized\\\")\"\n        },\n        \"status\": {\n            \"type\": \"integer\",\n            \"description\": \"HTTP status code\"\n        }\n    }\n}\n</code></pre>"},{"location":"api-reference/#forbidden","title":"Forbidden","text":"<p>Forbidden - Insufficient permissions</p> <p></p> application/json <p><pre><code>{\n    \"message\": \"string\",\n    \"status\": 0\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"message\": {\n            \"type\": \"string\",\n            \"description\": \"Error message (e.g., \\\"HTTP 401 Unauthorized\\\")\"\n        },\n        \"status\": {\n            \"type\": \"integer\",\n            \"description\": \"HTTP status code\"\n        }\n    }\n}\n</code></pre>"},{"location":"api-reference/#notfound","title":"NotFound","text":"<p>Resource not found</p> <p></p> application/json <p><pre><code>{\n    \"message\": \"string\",\n    \"status\": 0\n}\n</code></pre> \u26a0\ufe0f This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information.</p> Schema of the response body <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"message\": {\n            \"type\": \"string\",\n            \"description\": \"Error message (e.g., \\\"HTTP 401 Unauthorized\\\")\"\n        },\n        \"status\": {\n            \"type\": \"integer\",\n            \"description\": \"HTTP status code\"\n        }\n    }\n}\n</code></pre>"},{"location":"api-reference/#common-parameters","title":"Common parameters","text":"<p>This section describes common parameters that are reused across operations.</p>"},{"location":"api-reference/#uuidpath","title":"uuidPath","text":"Name In Type Default Nullable Description <code>uuid</code> path string No"},{"location":"api-reference/#security-schemes","title":"Security schemes","text":"Name Type Scheme Description X-Authorization apiKey Authorization token passed in X-Authorization header. Obtain tokens via Authorization Token endpoints."},{"location":"api-reference/#tags","title":"Tags","text":"Name Description Authorizations Role-based access control Authorization Tokens Authentication token management TLCs Traffic Light Controller management Sessions Active session management Session Logs Historical session data"},{"location":"api-endpoints/","title":"Subject Interface REST API","text":"<p>The Subject Interface REST API provides operational endpoints for managing streaming sessions, subjects (TLCs), and authorization. Resources are automatically scoped to your domain and account context.</p> <p>TLC Terminology</p> <p>The interface originally served Traffic Light Controllers (TLCs), and this legacy terminology persists in the API specifications for backward compatibility. \"TLC\" now refers to any connected entity: traffic controllers, sensors, barriers, displays, or any C-ITS participant. See Terminology Reference for the mapping between legacy and generic terminology.</p>"},{"location":"api-endpoints/#getting-started","title":"Getting Started","text":"<p>New to the Subject Interface API? Start here for quick implementation:</p> <ul> <li>Quick Start Guide - 15-minute implementation walkthrough</li> <li>Common Workflows - Step-by-step task guides</li> </ul>"},{"location":"api-endpoints/#quick-reference","title":"Quick Reference","text":"<p>Fast access to essential information:</p> <ul> <li>API Endpoints Reference - Concise endpoint documentation</li> <li>Endpoint Permissions Matrix - Role capability reference</li> <li>OpenAPI specification - OpenAPI 3.0 specification</li> </ul>"},{"location":"api-endpoints/getting-started/common-workflows/","title":"Common Workflows","text":"<p>Task-oriented guides for the most frequent Subject Interface operations. Each workflow provides step-by-step instructions with examples.</p>"},{"location":"api-endpoints/getting-started/common-workflows/#environment-variables","title":"Environment Variables","text":"<p>Set these environment variables to make the examples directly runnable:</p> <pre><code># Base URL for the Subject Interface API\nexport STREAMING_API_BASEURL=\"https://localhost/api\"\n\n# Authorization token\nexport STREAMING_API_ADMIN_TOKEN=\"your-admin-token\"\n\n# Domain and security configuration\nexport STREAMING_API_DOMAIN=\"dev_001\"\nexport STREAMING_API_SECURITY_MODE=\"TLSv1.2\"  # or \"NONE\"\nexport STREAMING_API_IDENTIFIER=\"sub00001\"\n\n# Variables populated from API responses\nexport TLC_UUID=\"...\"          # Returned from TLC registration\nexport AUTH_UUID=\"...\"          # Returned from authorization creation\nexport SESSION_TOKEN=\"...\"      # Returned from session creation\nexport TOKEN_UUID=\"...\"         # Returned from token generation\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#tlcsubject-management","title":"TLC/Subject Management","text":""},{"location":"api-endpoints/getting-started/common-workflows/#register-a-new-tlc-subject","title":"Register a New TLC (Subject)","text":"<p>When: Setting up a new data-producing entity (traffic controller, sensor, etc.)</p> <p>Steps:</p> <ul> <li>Choose an 8-character identifier (lowercase alphanumeric, underscores, hyphens)</li> <li>Send registration request</li> </ul> <pre><code>curl -X POST ${STREAMING_API_BASEURL}/v1/tlcs \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"identifier\": \"sub00001\"}'\n</code></pre> <ul> <li>Save the returned UUID for future reference</li> </ul>"},{"location":"api-endpoints/getting-started/common-workflows/#remove-a-tlc","title":"Remove a TLC","text":"<p>When: Decommissioning equipment or cleaning up unused registrations</p> <p>Steps:</p> <ul> <li>List TLCs to find the target UUID</li> <li>Delete the TLC (terminates any active sessions)</li> </ul> <pre><code>curl -X DELETE ${STREAMING_API_BASEURL}/v1/tlcs/${TLC_UUID} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#access-control-management","title":"Access Control Management","text":""},{"location":"api-endpoints/getting-started/common-workflows/#set-up-user-access","title":"Set Up User Access","text":"<p>When: Granting API access to team members or systems</p> <p>Steps:</p> <ul> <li>Create authorization with appropriate role</li> </ul> <pre><code>curl -X POST ${STREAMING_API_BASEURL}/v1/authorizations \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"role\": \"TLC_ANALYST\",\n    \"tlcIdentifiers\": [\"sub00001\", \"sub00002\"]\n  }'\n</code></pre> <ul> <li>Generate API token for the authorization</li> </ul> <pre><code>curl -X POST ${STREAMING_API_BASEURL}/v1/authorizationtokens \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"authorization\": \"${AUTH_UUID}\"}'\n</code></pre> <ul> <li>Securely share the token with the user</li> </ul>"},{"location":"api-endpoints/getting-started/common-workflows/#grant-domain-wide-access","title":"Grant Domain-Wide Access","text":"<p>When: Setting up admin users or system accounts</p> <p>Steps:</p> <ul> <li>Create authorization without TLC scope restriction</li> </ul> <pre><code>curl -X POST ${STREAMING_API_BASEURL}/v1/authorizations \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"role\": \"BROKER_SYSTEM\"}'\n</code></pre> <ul> <li>Generate token as above</li> </ul>"},{"location":"api-endpoints/getting-started/common-workflows/#revoke-user-access","title":"Revoke User Access","text":"<p>When: Employee departure, security incident, or access cleanup</p> <p>Steps:</p> <ul> <li>List authorization tokens to find target</li> </ul> <pre><code>curl -X GET ${STREAMING_API_BASEURL}/v1/authorizationtokens \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre> <ul> <li>Revoke specific tokens</li> </ul> <pre><code>curl -X DELETE ${STREAMING_API_BASEURL}/v1/authorizationtokens/${TOKEN_UUID} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre> <ul> <li>(Optional) Delete the authorization entirely</li> </ul> <pre><code>curl -X DELETE ${STREAMING_API_BASEURL}/v1/authorizations/${AUTH_UUID} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#session-management","title":"Session Management","text":""},{"location":"api-endpoints/getting-started/common-workflows/#create-a-simple-session","title":"Create a Simple Session","text":"<p>When: Setting up single TLC data streaming</p> <p>Steps:</p> <ul> <li>Ensure TLC is registered</li> <li>Create singleplex session</li> </ul> <pre><code>curl -X POST ${STREAMING_API_BASEURL}/v1/sessions \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"domain\": \"'${STREAMING_API_DOMAIN}'\",\n    \"type\": \"TLC\",\n    \"protocol\": \"TCPStreaming_Singleplex\", \n    \"details\": {\n      \"securityMode\": \"'${STREAMING_API_SECURITY_MODE:-TLSv1.2}'\",\n      \"tlcIdentifier\": \"'${STREAMING_API_IDENTIFIER}'\"\n    }\n  }'\n</code></pre> <p>Response: <pre><code>{\n  \"domain\": \"dev_001\",\n  \"type\": \"TLC\", \n  \"token\": \"session-token-abc123\",\n  \"protocol\": \"TCPStreaming_Singleplex\",\n  \"details\": {\n    \"securityMode\": \"TLSv1.2\",\n    \"keepAliveTimeout\": \"PT10S\",\n    \"payloadRateLimit\": 12,\n    \"payloadRateLimitDuration\": \"PT5S\",\n    \"payloadThroughputLimit\": 60,\n    \"payloadThroughputLimitDuration\": \"PT5S\",\n    \"clockDiffLimit\": \"PT3S\",\n    \"clockDiffLimitDuration\": \"PT1M\",\n    \"listener\": {\n      \"host\": \"streaming.example.com\",\n      \"port\": 8443,\n      \"expiration\": \"2024-01-15T10:30:00Z\"\n    },\n    \"tlcIdentifier\": \"sub00001\"\n  }\n}\n</code></pre></p> <ul> <li>Connect to streaming endpoint using returned connection details</li> </ul>"},{"location":"api-endpoints/getting-started/common-workflows/#create-multi-tlc-session","title":"Create Multi-TLC Session","text":"<p>When: Aggregating data from multiple sources</p> <p>Step:</p> <p>Create multiplex session with TLC list</p> <pre><code>curl -X POST ${STREAMING_API_BASEURL}/v1/sessions \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"domain\": \"'${STREAMING_API_DOMAIN}'\",\n    \"type\": \"Broker\",\n    \"protocol\": \"TCPStreaming_Multiplex\",\n    \"details\": {\n      \"securityMode\": \"'${STREAMING_API_SECURITY_MODE:-TLSv1.2}'\",\n      \"tlcIdentifiers\": [\"sub00001\", \"sub00002\", \"sub00003\"]\n    }\n  }'\n</code></pre> <p>Response: <pre><code>{\n  \"domain\": \"dev_001\",\n  \"type\": \"Broker\", \n  \"token\": \"session-token-xyz789\",\n  \"protocol\": \"TCPStreaming_Multiplex\",\n  \"details\": {\n    \"securityMode\": \"TLSv1.2\",\n    \"keepAliveTimeout\": \"PT10S\",\n    \"payloadRateLimit\": 12,\n    \"payloadRateLimitDuration\": \"PT5S\",\n    \"payloadThroughputLimit\": 60,\n    \"payloadThroughputLimitDuration\": \"PT5S\",\n    \"clockDiffLimit\": \"PT3S\",\n    \"clockDiffLimitDuration\": \"PT1M\",\n    \"listener\": {\n      \"host\": \"streaming.example.com\",\n      \"port\": 8444,\n      \"expiration\": \"2024-01-15T10:30:00Z\"\n    },\n    \"tlcIdentifiers\": [\"sub00001\", \"sub00002\", \"sub00003\"]\n  }\n}\n</code></pre></p>"},{"location":"api-endpoints/getting-started/common-workflows/#update-session-scope","title":"Update Session Scope","text":"<p>When: Adding/removing TLCs from active multiplex session</p> <p>Step:</p> <p>Update session with new TLC list</p> <pre><code>curl -X PUT ${STREAMING_API_BASEURL}/v1/sessions/${SESSION_TOKEN} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"securityMode\": \"'${STREAMING_API_SECURITY_MODE:-TLSv1.2}'\",\n    \"tlcIdentifiers\": [\"sub00001\", \"sub00002\", \"sub00003\", \"sub00004\"]\n  }'\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#terminate-session","title":"Terminate Session","text":"<p>When: Ending data streaming or emergency shutdown</p> <p>Step:</p> <p>Delete the session</p> <pre><code>curl -X DELETE ${STREAMING_API_BASEURL}/v1/sessions/${SESSION_TOKEN} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#token-management","title":"Token Management","text":""},{"location":"api-endpoints/getting-started/common-workflows/#rotate-api-tokens","title":"Rotate API Tokens","text":"<p>When: Regular security maintenance or suspected compromise</p> <p>Steps:</p> <ul> <li>Create new token for same authorization</li> </ul> <pre><code>curl -X POST ${STREAMING_API_BASEURL}/v1/authorizationtokens \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"authorization\": \"${AUTH_UUID}\"}'\n</code></pre> <ul> <li>Update systems to use new token</li> <li>Test new token functionality</li> <li>Revoke old token</li> </ul> <pre><code>curl -X DELETE ${STREAMING_API_BASEURL}/v1/authorizationtokens/${OLD_TOKEN_UUID} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#emergency-token-revocation","title":"Emergency Token Revocation","text":"<p>When: Security incident or compromised credentials</p> <p>Steps:</p> <ul> <li>Immediately revoke compromised token</li> </ul> <pre><code>curl -X DELETE ${STREAMING_API_BASEURL}/v1/authorizationtokens/${COMPROMISED_TOKEN_UUID} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre> <ul> <li>Create replacement token if needed</li> <li>Update affected systems</li> <li>Review access logs for suspicious activity</li> </ul>"},{"location":"api-endpoints/getting-started/common-workflows/#monitoring-and-troubleshooting","title":"Monitoring and Troubleshooting","text":""},{"location":"api-endpoints/getting-started/common-workflows/#check-session-status","title":"Check Session Status","text":"<p>When: Verifying active connections or debugging issues</p> <p>Steps:</p> <ul> <li>List active sessions</li> </ul> <pre><code>curl -X GET ${STREAMING_API_BASEURL}/v1/sessions \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre> <ul> <li>Get specific session details</li> </ul> <pre><code>curl -X GET ${STREAMING_API_BASEURL}/v1/sessions/${SESSION_TOKEN} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#review-session-history","title":"Review Session History","text":"<p>When: Troubleshooting connection issues or analyzing usage patterns</p> <p>Steps:</p> <ul> <li>Query session logs with time range</li> </ul> <pre><code>curl -X GET \"${STREAMING_API_BASEURL}/v1/sessionlogs?from=2024-01-15T00:00:00Z&amp;until=2024-01-15T23:59:59Z\" \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre> <ul> <li>Get specific session log details</li> </ul> <pre><code>curl -X GET ${STREAMING_API_BASEURL}/v1/sessionlogs/${SESSION_TOKEN} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#debug-authentication-issues","title":"Debug Authentication Issues","text":"<p>When: Receiving 401/403 errors</p> <p>Steps:</p> <ul> <li>Verify token is active</li> </ul> <pre><code>curl -X GET ${STREAMING_API_BASEURL}/v1/authorizationtokens \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre> <ul> <li>Check authorization permissions</li> </ul> <pre><code>curl -X GET ${STREAMING_API_BASEURL}/v1/authorizations/${AUTH_UUID} \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre> <ul> <li>Test token with simple endpoint</li> </ul> <pre><code>curl -X GET ${STREAMING_API_BASEURL}/v1/tlcs \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\"\n</code></pre>"},{"location":"api-endpoints/getting-started/common-workflows/#workflow-quick-reference","title":"Workflow Quick Reference","text":"Task Primary Endpoint Required Role Register TLC <code>POST /v1/tlcs</code> TLC_ADMIN Create user access <code>POST /v1/authorizations</code> TLC/BROKER/MONITOR_ADMIN Generate token <code>POST /v1/authorizationtokens</code> *_ADMIN Start streaming <code>POST /v1/sessions</code> _ADMIN/_SYSTEM Monitor sessions <code>GET /v1/sessionlogs</code> _ADMIN/_ANALYST <p>For detailed parameter reference, see Endpoints Reference.</p>"},{"location":"api-endpoints/getting-started/quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with the Subject Interface REST API in 15 minutes. This guide walks you through the essential steps to create your first streaming session.</p>"},{"location":"api-endpoints/getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>API endpoint URL</li> <li>Administrative authorization token for initial setup</li> <li>Basic understanding of REST API concepts</li> </ul>"},{"location":"api-endpoints/getting-started/quick-start/#environment-variables","title":"Environment Variables","text":"<p>Set these environment variables to make the examples directly runnable:</p> <pre><code># Base URL for the Subject Interface API\nexport STREAMING_API_BASEURL=\"https://localhost/api\"\n\n# Authorization token\nexport STREAMING_API_ADMIN_TOKEN=\"your-admin-token\"\n\n# Domain and configuration\nexport STREAMING_API_DOMAIN=\"dev_001\"\nexport STREAMING_API_IDENTIFIER=\"sub00001\"\nexport STREAMING_API_SECURITY_MODE=\"TLSv1.2\"  # or \"NONE\"\n\n# Variables populated from API responses (save these as you go)\nexport AUTH_UUID=\"...\"          # From Step 2\nexport GENERATED_TOKEN=\"...\"   # From Step 3\n</code></pre>"},{"location":"api-endpoints/getting-started/quick-start/#4-step-implementation","title":"4-Step Implementation","text":""},{"location":"api-endpoints/getting-started/quick-start/#step-1-register-a-tlc-subject","title":"Step 1: Register a TLC (Subject)","text":"<p>First, register a TLC (data-producing entity) in your domain:</p> <pre><code>curl -X POST \\\n  ${STREAMING_API_BASEURL}/v1/tlcs \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"identifier\": \"'${STREAMING_API_IDENTIFIER}'\"\n  }'\n</code></pre> <p>Response: <pre><code>{\n  \"uuid\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"identifier\": \"sub00001\",\n  \"domain\": \"dev_001\",\n  \"account\": \"your-account\",\n  \"type\": \"TCPStreaming\"\n}\n</code></pre></p> <p>Note: TLC identifiers must be exactly 8 lowercase alphanumeric characters, underscores, and hyphens.</p>"},{"location":"api-endpoints/getting-started/quick-start/#step-2-create-an-authorization","title":"Step 2: Create an Authorization","text":"<p>Create an authorization for operational access:</p> <pre><code>curl -X POST \\\n  ${STREAMING_API_BASEURL}/v1/authorizations \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"role\": \"TLC_SYSTEM\"\n  }'\n</code></pre> <p>Response: <pre><code>{\n  \"uuid\": \"660f9500-f39c-52e5-b827-556766551111\",\n  \"domain\": \"dev_001\", \n  \"account\": \"your-account\",\n  \"role\": \"TLC_SYSTEM\",\n  \"tlcIdentifiers\": []\n}\n</code></pre></p>"},{"location":"api-endpoints/getting-started/quick-start/#step-3-generate-an-api-token","title":"Step 3: Generate an API Token","text":"<p>Generate a token for the authorization:</p> <pre><code>curl -X POST \\\n  ${STREAMING_API_BASEURL}/v1/authorizationtokens \\\n  -H \"X-Authorization: ${STREAMING_API_ADMIN_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"authorization\": \"'${AUTH_UUID}'\"\n  }'\n</code></pre> <p>Response: <pre><code>{\n  \"uuid\": \"770fa600-04ad-63f6-c938-667877662222\",\n  \"token\": \"dtNB_vhvJ0wgTGf1N0DxN38_AmTL_4yiPRZdqZSuK3k\",\n  \"authorization\": \"660f9500-f39c-52e5-b827-556766551111\"\n}\n</code></pre></p> <p>Save this token - export it as <code>GENERATED_TOKEN</code> for the next step.</p>"},{"location":"api-endpoints/getting-started/quick-start/#step-4-create-a-streaming-session","title":"Step 4: Create a Streaming Session","text":"<p>Create a streaming session using your new token:</p> <pre><code>curl -X POST \\\n  ${STREAMING_API_BASEURL}/v1/sessions \\\n  -H \"X-Authorization: ${GENERATED_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"domain\": \"'${STREAMING_API_DOMAIN}'\",\n    \"type\": \"TLC\",\n    \"protocol\": \"TCPStreaming_Singleplex\",\n    \"details\": {\n      \"securityMode\": \"'${STREAMING_API_SECURITY_MODE}'\",\n      \"tlcIdentifier\": \"'${STREAMING_API_IDENTIFIER}'\"\n    }\n  }'\n</code></pre> <p>Response: <pre><code>{\n  \"domain\": \"dev_001\",\n  \"type\": \"TLC\", \n  \"token\": \"session-token-abc123\",\n  \"protocol\": \"TCPStreaming_Singleplex\",\n  \"details\": {\n    \"securityMode\": \"TLSv1.2\",\n    \"keepAliveTimeout\": \"PT10S\",\n    \"payloadRateLimit\": 12,\n    \"payloadRateLimitDuration\": \"PT5S\",\n    \"payloadThroughputLimit\": 60,\n    \"payloadThroughputLimitDuration\": \"PT5S\",\n    \"clockDiffLimit\": \"PT3S\",\n    \"clockDiffLimitDuration\": \"PT1M\",\n    \"listener\": {\n      \"host\": \"streaming.example.com\",\n      \"port\": 8443,\n      \"expiration\": \"2024-01-15T10:30:00Z\"\n    },\n    \"tlcIdentifier\": \"sub00001\"\n  }\n}\n</code></pre></p>"},{"location":"api-endpoints/getting-started/quick-start/#verification","title":"Verification","text":"<p>Test your setup by listing your active sessions:</p> <pre><code>curl -X GET \\\n  ${STREAMING_API_BASEURL}/v1/sessions \\\n  -H \"X-Authorization: ${GENERATED_TOKEN}\"\n</code></pre> <p>You should see your active session in the response.</p>"},{"location":"api-endpoints/getting-started/quick-start/#whats-next","title":"What's Next?","text":"<ul> <li>TCP Streaming: See Code Examples for complete working implementations in multiple languages</li> <li>Monitoring: Request session logs for troubleshooting</li> </ul> <p>For complete reference documentation, see API Endpoints Reference.</p>"},{"location":"api-endpoints/reference/endpoints-reference/","title":"API Endpoints Reference","text":"<p>Complete reference for all Subject Interface REST API endpoints with request/response examples and field definitions.</p>"},{"location":"api-endpoints/reference/endpoints-reference/#data-types","title":"Data Types","text":"Type Description Example string Text value <code>\"example-value\"</code> number Numeric value <code>8443</code> boolean True/false value <code>true</code> array List of values <code>[\"value1\", \"value2\"]</code> object JSON object <code>{\"key\": \"value\"}</code> enum Fixed set of values <code>\"TLC\"</code> (from <code>TLC</code>, <code>Broker</code>, <code>Monitor</code>) timestamp Unix epoch milliseconds <code>1640995200000</code> iso8601 ISO 8601 datetime string <code>\"2024-01-15T10:30:00Z\"</code> uuid UUID identifier <code>\"550e8400-e29b-41d4-a716-446655440000\"</code>"},{"location":"api-endpoints/reference/endpoints-reference/#authentication","title":"Authentication","text":"<p>Header: <code>X-Authorization: your-token-value</code></p> <p>Required for: All endpoints except public documentation</p>"},{"location":"api-endpoints/reference/endpoints-reference/#sessions","title":"Sessions","text":""},{"location":"api-endpoints/reference/endpoints-reference/#list-sessions","title":"List Sessions","text":"<pre><code>GET /v1/sessions\nGET /v1/sessions?type=TLC\nGET /v1/sessions?protocol=TCPStreaming_Multiplex\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin/System</p> <p>Query Parameters:</p> Parameter Type Required Description Valid Values <code>type</code> enum No Filter by session type <code>TLC</code>, <code>Broker</code>, <code>Monitor</code> <code>protocol</code> enum No Filter by protocol <code>TCPStreaming_Singleplex</code>, <code>TCPStreaming_Multiplex</code> <p>Response: Array of session objects</p> <pre><code>[\n  {\n    \"domain\": \"your-domain\",\n    \"type\": \"TLC\",\n    \"token\": \"session-token-123\",\n    \"protocol\": \"TCPStreaming_Singleplex\",\n    \"details\": {\n      \"securityMode\": \"TLSv1.2\",\n      \"listener\": {\n        \"host\": \"streaming.example.com\",\n        \"port\": 8443,\n        \"expiration\": \"2024-01-15T10:30:00Z\"\n      },\n      \"tlcIdentifier\": \"device01\"\n    }\n  }\n]\n</code></pre> <p>Response Fields:</p> Field Type Description Notes <code>domain</code> string Domain context Matches token's domain <code>type</code> enum Session type <code>TLC</code>, <code>Broker</code>, or <code>Monitor</code> <code>token</code> string Unique session identifier System-generated <code>protocol</code> enum Communication protocol <code>TCPStreaming_Singleplex</code> or <code>TCPStreaming_Multiplex</code> <code>details</code> object Session configuration and limits Contains operational parameters <code>details.securityMode</code> enum Encryption mode <code>NONE</code> or <code>TLSv1.2</code> <code>details.keepAliveTimeout</code> iso8601 Maximum idle time before connection timeout ISO 8601 duration format. See Connection Timeout Enforcement <code>details.payloadRateLimit</code> number Maximum payload messages per duration Rate limiting for message frequency. See Payload Rate Limiting <code>details.payloadRateLimitDuration</code> iso8601 Time window for rate limit ISO 8601 duration format. See Payload Rate Limiting <code>details.payloadThroughputLimit</code> number Maximum bytes per duration Bandwidth limiting in bytes. See Throughput Limiting <code>details.payloadThroughputLimitDuration</code> iso8601 Time window for throughput limit ISO 8601 duration format. See Throughput Limiting <code>details.clockDiffLimit</code> iso8601 Maximum allowed clock difference Time synchronization tolerance. See Clock Sync Enforcement <code>details.clockDiffLimitDuration</code> iso8601 Clock difference measurement window ISO 8601 duration format. See Clock Sync Enforcement <code>details.listener</code> object Connection details Present in responses only <code>details.listener.host</code> string Streaming server hostname System-determined <code>details.listener.port</code> number TCP port number Range: 1024-65535 <code>details.listener.expiration</code> iso8601 Session expiration time ISO 8601 with Z suffix <code>details.tlcIdentifier</code> string Single TLC identifier For singleplex sessions only <code>details.tlcIdentifiers</code> array Multiple TLC identifiers For multiplex sessions only"},{"location":"api-endpoints/reference/endpoints-reference/#create-session","title":"Create Session","text":"<pre><code>POST /v1/sessions\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin/System</p> <p>Request Body: <pre><code>{\n  \"domain\": \"your-domain\",\n  \"type\": \"TLC\\|Broker\\|Monitor\",\n  \"protocol\": \"TCPStreaming_Singleplex|TCPStreaming_Multiplex\",\n  \"details\": {\n    \"securityMode\": \"NONE|TLSv1.2\",\n    \"tlcIdentifier\": \"device01\",          // Singleplex only\n    \"tlcIdentifiers\": [\"sub00001\", \"sub00002\"]  // Multiplex only\n  }\n}\n</code></pre></p> <p>Request Fields:</p> Field Type Required Description Validation <code>domain</code> string Yes Domain context Must match token's domain <code>type</code> enum Yes Session type <code>TLC</code>, <code>Broker</code>, or <code>Monitor</code> <code>protocol</code> enum Yes Communication protocol <code>TCPStreaming_Singleplex</code> or <code>TCPStreaming_Multiplex</code> <code>details</code> object Yes Session configuration Structure varies by protocol <code>details.securityMode</code> enum Yes Encryption mode <code>NONE</code> or <code>TLSv1.2</code> <code>details.tlcIdentifier</code> string Conditional Single TLC identifier Required for singleplex, 8 chars, lowercase alphanumeric, underscore, hyphen <code>details.tlcIdentifiers</code> array Conditional Multiple TLC identifiers Required for multiplex, 1-100 items <p>Response: Session object with connection details (same structure as List Sessions)</p> <pre><code>{\n  \"domain\": \"dev_001\",\n  \"type\": \"TLC\", \n  \"token\": \"session-token-abc123\",\n  \"protocol\": \"TCPStreaming_Singleplex\",\n  \"details\": {\n    \"securityMode\": \"TLSv1.2\",\n    \"keepAliveTimeout\": \"PT10S\",\n    \"payloadRateLimit\": 12,\n    \"payloadRateLimitDuration\": \"PT5S\",\n    \"payloadThroughputLimit\": 60,\n    \"payloadThroughputLimitDuration\": \"PT5S\",\n    \"clockDiffLimit\": \"PT3S\",\n    \"clockDiffLimitDuration\": \"PT1M\",\n    \"listener\": {\n      \"host\": \"streaming.example.com\",\n      \"port\": 8443,\n      \"expiration\": \"2024-01-15T10:30:00Z\"\n    },\n    \"tlcIdentifier\": \"sub00001\"\n  }\n}\n</code></pre> <p>Response Fields:</p> Field Type Description Notes <code>domain</code> string Domain context Matches request domain <code>type</code> enum Session type <code>TLC</code>, <code>Broker</code>, or <code>Monitor</code> <code>token</code> string Unique session identifier System-generated, used for streaming connection <code>protocol</code> enum Communication protocol <code>TCPStreaming_Singleplex</code> or <code>TCPStreaming_Multiplex</code> <code>details</code> object Session configuration and limits Contains operational parameters <code>details.securityMode</code> enum Encryption mode <code>NONE</code> or <code>TLSv1.2</code> <code>details.keepAliveTimeout</code> iso8601 Maximum idle time before connection timeout ISO 8601 duration format. See Connection Timeout Enforcement <code>details.payloadRateLimit</code> number Maximum payload messages per duration Rate limiting for message frequency. See Payload Rate Limiting <code>details.payloadRateLimitDuration</code> iso8601 Time window for rate limit ISO 8601 duration format. See Payload Rate Limiting <code>details.payloadThroughputLimit</code> number Maximum bytes per duration Bandwidth limiting in bytes. See Throughput Limiting <code>details.payloadThroughputLimitDuration</code> iso8601 Time window for throughput limit ISO 8601 duration format. See Throughput Limiting <code>details.clockDiffLimit</code> iso8601 Maximum allowed clock difference Time synchronization tolerance. See Clock Sync Enforcement <code>details.clockDiffLimitDuration</code> iso8601 Clock difference measurement window ISO 8601 duration format. See Clock Sync Enforcement <code>details.listener</code> object Connection details Streaming endpoint information <code>details.listener.host</code> string Streaming server hostname System-determined endpoint <code>details.listener.port</code> number TCP port number Range: 1024-65535 <code>details.listener.expiration</code> iso8601 Session expiration time ISO 8601 with Z suffix <code>details.tlcIdentifier</code> string Single TLC identifier For singleplex sessions only <code>details.tlcIdentifiers</code> array Multiple TLC identifiers For multiplex sessions only"},{"location":"api-endpoints/reference/endpoints-reference/#get-session","title":"Get Session","text":"<pre><code>GET /v1/sessions/{token}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin/System</p> <p>Path Parameters:</p> Parameter Type Required Description <code>token</code> string Yes Session token <p>Response: Single session object (same structure as List Sessions)</p>"},{"location":"api-endpoints/reference/endpoints-reference/#update-session","title":"Update Session","text":"<pre><code>PUT /v1/sessions/{token}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin/System</p> <p>Note: Multiplex sessions only</p> <p>Request Body: <pre><code>{\n  \"securityMode\": \"TLSv1.2\",  // Must match existing\n  \"tlcIdentifiers\": [\"sub00001\", \"sub00002\", \"sub00003\"]\n}\n</code></pre></p> <p>Request Fields:</p> Field Type Required Description Validation <code>securityMode</code> enum Yes Encryption mode Must match existing session <code>tlcIdentifiers</code> array Yes Updated TLC list 1-100 valid TLC identifiers"},{"location":"api-endpoints/reference/endpoints-reference/#delete-session","title":"Delete Session","text":"<pre><code>DELETE /v1/sessions/{token}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Response: 204 No Content</p>"},{"location":"api-endpoints/reference/endpoints-reference/#session-logs","title":"Session Logs","text":""},{"location":"api-endpoints/reference/endpoints-reference/#list-session-logs","title":"List Session Logs","text":"<pre><code>GET /v1/sessionlogs?from=2024-01-15T00:00:00Z&amp;until=2024-01-15T23:59:59Z\n</code></pre> <p>Required Roles: TLC/Broker Admin/Analyst, Monitor Admin/System</p> <p>Query Parameters:</p> Parameter Type Required Description Format <code>from</code> iso8601 Yes Start time ISO 8601 with Z suffix <code>until</code> iso8601 Yes End time ISO 8601 with Z suffix <p>Response: Array of session log objects</p> <pre><code>[\n  {\n    \"token\": \"session-token-123\",\n    \"domain\": \"your-domain\",\n    \"account\": \"your-account\",\n    \"type\": \"TLC\",\n    \"protocol\": \"TCPStreaming_Singleplex\",\n    \"details\": \"{\\\"securityMode\\\":\\\"TLSv1.2\\\",\\\"tlcIdentifier\\\":\\\"device01\\\"}\",\n    \"created\": 1640995200000,\n    \"connected\": 1640995205000,\n    \"ended\": 1640998800000,\n    \"endReason\": \"CLIENT_DISCONNECT\",\n    \"remoteAddress\": \"192.168.1.100\"\n  }\n]\n</code></pre> <p>Response Fields:</p> Field Type Required Description Notes <code>token</code> string Yes Session token Unique identifier <code>domain</code> string Yes Domain context Domain name <code>account</code> string Yes Account identifier Account name <code>type</code> enum Yes Session type <code>TLC</code>, <code>Broker</code>, or <code>Monitor</code> <code>protocol</code> enum Yes Protocol used <code>TCPStreaming_Singleplex</code> or <code>TCPStreaming_Multiplex</code> <code>details</code> string Yes JSON-encoded session details Serialized configuration <code>created</code> timestamp Yes Session creation time Unix epoch milliseconds <code>connected</code> timestamp No First connection time Unix epoch milliseconds, null if never connected <code>ended</code> timestamp No Session end time Unix epoch milliseconds, null if still active <code>endReason</code> string No Termination reason See End Reasons below <code>remoteAddress</code> string No Client IP address IPv4/IPv6 address <p>End Reasons:</p> Reason Description Cause <code>CLIENT_DISCONNECT</code> Client closed connection Normal client-initiated termination <code>SESSION_EXPIRED</code> Session reached expiration Time-based expiration <code>ADMIN_TERMINATION</code> Admin deleted session Manual termination via DELETE endpoint <code>TLC_DELETED</code> Referenced TLC was deleted TLC resource removal <code>TOKEN_REVOKED</code> Session token was revoked Token management action <code>CONNECTION_ERROR</code> Network/TCP error Technical connectivity issue <code>PROTOCOL_ERROR</code> Streaming protocol violation Invalid client behavior"},{"location":"api-endpoints/reference/endpoints-reference/#get-session-log","title":"Get Session Log","text":"<pre><code>GET /v1/sessionlogs/{token}\n</code></pre> <p>Required Roles: TLC/Broker Admin/Analyst, Monitor Admin/System</p> <p>Response: Single session log object (same structure as List Session Logs)</p>"},{"location":"api-endpoints/reference/endpoints-reference/#tlcs-subjects","title":"TLCs (Subjects)","text":""},{"location":"api-endpoints/reference/endpoints-reference/#list-tlcs","title":"List TLCs","text":"<pre><code>GET /v1/tlcs\n</code></pre> <p>Required Roles: TLC Admin/Analyst, Broker Admin/System/Analyst, Monitor Admin/System</p> <p>Response: Array of TLC objects</p> <pre><code>[\n  {\n    \"uuid\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"identifier\": \"device01\",\n    \"domain\": \"your-domain\", \n    \"account\": \"your-account\",\n    \"type\": \"TCPStreaming\"\n  }\n]\n</code></pre> <p>Response Fields:</p> Field Type Description Notes <code>uuid</code> uuid Unique TLC identifier System-generated UUID <code>identifier</code> string TLC identifier 8 chars, pattern: <code>^[a-z0-9_-]{8}$</code> <code>domain</code> string Domain context Inherited from token <code>account</code> string Account context Inherited from token <code>type</code> enum TLC type Currently only <code>TCPStreaming</code>"},{"location":"api-endpoints/reference/endpoints-reference/#create-tlc","title":"Create TLC","text":"<pre><code>POST /v1/tlcs\n</code></pre> <p>Required Roles: TLC Admin</p> <p>Request Body: <pre><code>{\n  \"identifier\": \"device01\"  // 8 chars, lowercase alphanumeric, underscore, hyphen\n}\n</code></pre></p> <p>Request Fields:</p> Field Type Required Description Validation <code>identifier</code> string Yes TLC identifier Exactly 8 chars, pattern: <code>^[a-z0-9_-]{8}$</code>, unique within domain <p>TLC Identifier Examples:</p> <ul> <li>Valid: <code>sub00001</code>, <code>device01</code>, <code>traffic1</code>, <code>sensor99</code>, <code>ctrl0001</code>, <code>zone12ab</code>, <code>dev_0001</code>, <code>test-001</code>, <code>prod_v01</code></li> <li>Invalid: <code>Device01</code> (uppercase), <code>device1</code> (7 chars), <code>device001</code> (9 chars), <code>dev@001</code> (invalid char)</li> </ul> <p>Response: TLC object with generated UUID (same structure as List TLCs)</p>"},{"location":"api-endpoints/reference/endpoints-reference/#get-tlc","title":"Get TLC","text":"<pre><code>GET /v1/tlcs/{uuid}\n</code></pre> <p>Required Roles: TLC Admin/Analyst, Broker Admin/System/Analyst, Monitor Admin/System</p> <p>Response: Single TLC object (same structure as List TLCs)</p>"},{"location":"api-endpoints/reference/endpoints-reference/#delete-tlc","title":"Delete TLC","text":"<pre><code>DELETE /v1/tlcs/{uuid}\n</code></pre> <p>Required Roles: TLC Admin</p> <p>Response: 204 No Content</p> <p>Note: Terminates any active sessions using this TLC</p>"},{"location":"api-endpoints/reference/endpoints-reference/#authorizations","title":"Authorizations","text":""},{"location":"api-endpoints/reference/endpoints-reference/#list-authorizations","title":"List Authorizations","text":"<pre><code>GET /v1/authorizations\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Response: Array of authorization objects</p> <pre><code>[\n  {\n    \"uuid\": \"660f9500-f39c-52e5-b827-556766551111\",\n    \"domain\": \"your-domain\",\n    \"account\": \"your-account\",\n    \"role\": \"TLC_SYSTEM\",\n    \"tlcIdentifiers\": [\"device01\", \"device02\"]\n  }\n]\n</code></pre> <p>Response Fields:</p> Field Type Description Notes <code>uuid</code> uuid Unique authorization ID System-generated UUID <code>domain</code> string Domain context Inherited from token <code>account</code> string Account context Inherited from token <code>role</code> enum Operational role See Role Types below <code>tlcIdentifiers</code> array TLC scope restriction Optional, for TLC roles only <p>Role Types:</p> Role Category Level Description <code>TLC_ADMIN</code> TLC Administrative TLC management and configuration <code>TLC_SYSTEM</code> TLC Operational Data generation and streaming <code>TLC_ANALYST</code> TLC Analytical Monitoring and analysis <code>BROKER_ADMIN</code> BROKER Administrative Broker service management <code>BROKER_SYSTEM</code> BROKER Operational Data aggregation and distribution <code>BROKER_ANALYST</code> BROKER Analytical Broker performance analysis <code>MONITOR_ADMIN</code> MONITOR Administrative Monitoring service management <code>MONITOR_SYSTEM</code> MONITOR Operational Read-only data consumption <p>TLC Scope Rules:</p> Role Category Scope Behavior Notes TLC Roles Optional TLC restriction Empty array = domain-wide access BROKER Roles Always domain-wide <code>tlcIdentifiers</code> ignored MONITOR Roles Always domain-wide <code>tlcIdentifiers</code> ignored"},{"location":"api-endpoints/reference/endpoints-reference/#create-authorization","title":"Create Authorization","text":"<pre><code>POST /v1/authorizations\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Request Body: <pre><code>{\n  \"role\": \"TLC_ADMIN\\|TLC_SYSTEM\\|TLC_ANALYST\\|BROKER_ADMIN\\|BROKER_SYSTEM\\|BROKER_ANALYST\\|MONITOR_ADMIN\\|MONITOR_SYSTEM\",\n  \"tlcIdentifiers\": [\"device01\", \"device02\"]  // Optional, TLC roles only\n}\n</code></pre></p> <p>Request Fields:</p> Field Type Required Description Validation <code>role</code> enum Yes Operational role Must be valid role from list above <code>tlcIdentifiers</code> array No TLC scope restriction Optional for TLC roles, ignored for others <p>Response: Authorization object with generated UUID (same structure as List Authorizations)</p>"},{"location":"api-endpoints/reference/endpoints-reference/#get-authorization","title":"Get Authorization","text":"<pre><code>GET /v1/authorizations/{uuid}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Response: Single authorization object (same structure as List Authorizations)</p>"},{"location":"api-endpoints/reference/endpoints-reference/#update-authorization","title":"Update Authorization","text":"<pre><code>PUT /v1/authorizations/{uuid}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Request Body: <pre><code>{\n  \"role\": \"TLC_ANALYST\",\n  \"tlcIdentifiers\": [\"device01\"]\n}\n</code></pre></p> <p>Request Fields: Same as Create Authorization</p>"},{"location":"api-endpoints/reference/endpoints-reference/#delete-authorization","title":"Delete Authorization","text":"<pre><code>DELETE /v1/authorizations/{uuid}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Response: 204 No Content</p> <p>Note: Automatically revokes all associated tokens</p>"},{"location":"api-endpoints/reference/endpoints-reference/#authorization-tokens","title":"Authorization Tokens","text":""},{"location":"api-endpoints/reference/endpoints-reference/#list-tokens","title":"List Tokens","text":"<pre><code>GET /v1/authorizationtokens\nGET /v1/authorizationtokens?authorization={uuid}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Query Parameters:</p> Parameter Type Required Description <code>authorization</code> uuid No Filter by authorization UUID <p>Response: Array of token objects</p> <pre><code>[\n  {\n    \"uuid\": \"770fa600-04ad-63f6-c938-667877662222\",\n    \"token\": \"dtNB_vhvJ0wgTGf1N0DxN38_AmTL_4yiPRZdqZSuK3k\",\n    \"authorization\": \"660f9500-f39c-52e5-b827-556766551111\"\n  }\n]\n</code></pre> <p>Response Fields:</p> Field Type Description Notes <code>uuid</code> uuid Unique token ID System-generated UUID <code>token</code> string Token value Base64url-encoded, cryptographically secure <code>authorization</code> uuid Associated authorization Must be valid authorization UUID <p>Token Format:</p> <ul> <li>Base64url-encoded strings</li> <li>Cryptographically random</li> <li>URL-safe characters only</li> <li>No expiration mechanism</li> <li>Case-sensitive</li> <li>Example: <code>dtNB_vhvJ0wgTGf1N0DxN38_AmTL_4yiPRZdqZSuK3k</code></li> </ul>"},{"location":"api-endpoints/reference/endpoints-reference/#create-token","title":"Create Token","text":"<pre><code>POST /v1/authorizationtokens\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Request Body: <pre><code>{\n  \"authorization\": \"660f9500-f39c-52e5-b827-556766551111\"\n}\n</code></pre></p> <p>Request Fields:</p> Field Type Required Description Validation <code>authorization</code> uuid Yes Associated authorization Must be valid authorization UUID within domain <p>Response: Token object with generated token value (same structure as List Tokens)</p>"},{"location":"api-endpoints/reference/endpoints-reference/#get-token","title":"Get Token","text":"<pre><code>GET /v1/authorizationtokens/{uuid}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Response: Single token object (same structure as List Tokens)</p>"},{"location":"api-endpoints/reference/endpoints-reference/#update-token","title":"Update Token","text":"<pre><code>PUT /v1/authorizationtokens/{uuid}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Request Body: <pre><code>{\n  \"authorization\": \"new-authorization-uuid\"\n}\n</code></pre></p> <p>Request Fields:</p> Field Type Required Description Notes <code>authorization</code> uuid Yes New authorization UUID Changes token's permissions and scope"},{"location":"api-endpoints/reference/endpoints-reference/#delete-token","title":"Delete Token","text":"<pre><code>DELETE /v1/authorizationtokens/{uuid}\n</code></pre> <p>Required Roles: TLC/Broker/Monitor Admin</p> <p>Response: 204 No Content</p> <p>Note: Immediately invalidates token for API access</p>"},{"location":"api-endpoints/reference/role-permissions/","title":"Endpoint Permissions Matrix","text":"<p>Quick reference for role-based access control across all Subject Interface API endpoints.</p>"},{"location":"api-endpoints/reference/role-permissions/#sessions-api","title":"Sessions API","text":"Endpoint Method TLC_ADMIN TLC_SYSTEM TLC_ANALYST BROKER_ADMIN BROKER_SYSTEM BROKER_ANALYST MONITOR_ADMIN MONITOR_SYSTEM <code>/v1/sessions</code> GET Yes Yes No Yes Yes No Yes Yes <code>/v1/sessions</code> POST Yes Yes No Yes Yes No Yes Yes <code>/v1/sessions/{token}</code> GET Yes Yes No Yes Yes No Yes Yes <code>/v1/sessions/{token}</code> PUT Yes Yes No Yes Yes No Yes Yes <code>/v1/sessions/{token}</code> DELETE Yes No No Yes No No Yes No <p>Notes: - TLC roles can only access sessions for their authorized TLC scope - BROKER and MONITOR roles have domain-wide session access - Only ADMIN roles can delete sessions</p>"},{"location":"api-endpoints/reference/role-permissions/#session-logs-api","title":"Session Logs API","text":"Endpoint Method TLC_ADMIN TLC_SYSTEM TLC_ANALYST BROKER_ADMIN BROKER_SYSTEM BROKER_ANALYST MONITOR_ADMIN MONITOR_SYSTEM <code>/v1/sessionlogs</code> GET Yes No Yes Yes No Yes Yes Yes <code>/v1/sessionlogs/{token}</code> GET Yes No Yes Yes No Yes Yes Yes <p>Notes: - SYSTEM roles generally don't need historical log access - ANALYST and ADMIN roles have read access to logs - MONITOR_SYSTEM has special read access for operational monitoring</p>"},{"location":"api-endpoints/reference/role-permissions/#tlcs-api","title":"TLCs API","text":"Endpoint Method TLC_ADMIN TLC_SYSTEM TLC_ANALYST BROKER_ADMIN BROKER_SYSTEM BROKER_ANALYST MONITOR_ADMIN MONITOR_SYSTEM <code>/v1/tlcs</code> GET Yes No Yes Yes Yes Yes Yes Yes <code>/v1/tlcs</code> POST Yes No No No No No No No <code>/v1/tlcs/{uuid}</code> GET Yes No Yes Yes Yes Yes Yes Yes <code>/v1/tlcs/{uuid}</code> DELETE Yes No No No No No No No <p>Notes: - Only TLC_ADMIN can create and delete TLC registrations - Most roles can read TLC information for discovery - TLC_SYSTEM doesn't need TLC management access</p>"},{"location":"api-endpoints/reference/role-permissions/#authorizations-api","title":"Authorizations API","text":"Endpoint Method TLC_ADMIN TLC_SYSTEM TLC_ANALYST BROKER_ADMIN BROKER_SYSTEM BROKER_ANALYST MONITOR_ADMIN MONITOR_SYSTEM <code>/v1/authorizations</code> GET Yes No No Yes No No Yes No <code>/v1/authorizations</code> POST Yes No No Yes No No Yes No <code>/v1/authorizations/{uuid}</code> GET Yes No No Yes No No Yes No <code>/v1/authorizations/{uuid}</code> PUT Yes No No Yes No No Yes No <code>/v1/authorizations/{uuid}</code> DELETE Yes No No Yes No No Yes No <p>Notes: - Only ADMIN roles can manage authorizations - Each ADMIN role can only manage authorizations within their category - SYSTEM and ANALYST roles have no authorization management access</p>"},{"location":"api-endpoints/reference/role-permissions/#authorization-tokens-api","title":"Authorization Tokens API","text":"Endpoint Method TLC_ADMIN TLC_SYSTEM TLC_ANALYST BROKER_ADMIN BROKER_SYSTEM BROKER_ANALYST MONITOR_ADMIN MONITOR_SYSTEM <code>/v1/authorizationtokens</code> GET Yes No No Yes No No Yes No <code>/v1/authorizationtokens</code> POST Yes No No Yes No No Yes No <code>/v1/authorizationtokens/{uuid}</code> GET Yes No No Yes No No Yes No <code>/v1/authorizationtokens/{uuid}</code> PUT Yes No No Yes No No Yes No <code>/v1/authorizationtokens/{uuid}</code> DELETE Yes No No Yes No No Yes No <p>Notes: - Only ADMIN roles can manage tokens - Token management is restricted to same role category - Token revocation is immediate and irreversible</p> <p>See Also: - Implementation: API Endpoints Reference - API Reference: API Endpoints Reference - Getting Started: Quick Start Guide - Architecture: Core Concepts</p>"},{"location":"appendix/evolution-terminology/","title":"Terminology Reference","text":""},{"location":"appendix/evolution-terminology/#legacy-terminology-mapping","title":"Legacy Terminology Mapping","text":"<p>The Subject Interface API uses legacy terminology from its original Traffic Light Controller (TLC) implementation for backward compatibility. The table below shows the mapping between legacy API terminology and the generic terminology that reflects the actual functionality:</p> Legacy API Terminology Generic Terminology Functional Purpose TLC (entity) SUBJECT Any entity or bi-directional communication channel TLC (session type) OWNER Session type for entities that own and manage subject data BROKER (session type) PARTICIPANT Session type for data exchange and distribution MONITOR (session type) LISTENER Session type for data observation and analytics TLC_ADMIN (role) OWNER_ADMIN Administrative role for subject owners TLC_SYSTEM (role) OWNER_SYSTEM Operational role for subject data production TLC_ANALYST (role) OWNER_ANALYST Analytical role for subject data analysis BROKER_ADMIN (role) PARTICIPANT_ADMIN Administrative role for data distribution BROKER_SYSTEM (role) PARTICIPANT_SYSTEM Operational role for data distribution BROKER_ANALYST (role) PARTICIPANT_ANALYST Analytical role for distribution analysis MONITOR_ADMIN (role) LISTENER_ADMIN Administrative role for monitoring MONITOR_SYSTEM (role) LISTENER_SYSTEM Operational role for data observation MONITOR_ANALYST (role) LISTENER_ANALYST Analytical role for monitoring analysis"},{"location":"appendix/evolution-terminology/#legacy-entity-names-in-api","title":"Legacy Entity Names in API","text":"Legacy API Entity Actually Represents TLC Any connected subject (traffic controller, sensor, barrier, display, etc.) AuthorizationTLC Authorization scope limited to specific subjects TLC Registration Registration of any connected entity within a domain"},{"location":"architecture/","title":"Architecture","text":"<p>This chapter covers the Subject Interface system architecture, security framework, and access control mechanisms.</p> <p>TLC Terminology</p> <p>The interface originally served Traffic Light Controllers (TLCs), and this legacy terminology persists in the API specifications for backward compatibility. \"TLC\" now refers to any connected entity: traffic controllers, sensors, barriers, displays, or any C-ITS participant. See Terminology Reference for the mapping between legacy and generic terminology.</p>"},{"location":"architecture/#architecture-overview","title":"Architecture Overview","text":"<p>The Subject Interface employs a dual-layer architecture for administrative control and data exchange:</p> <ul> <li>JSON-REST API Layer - Administrative control, lifecycle management, and configuration</li> <li>TCP Streaming Protocol Layer - Real-time data exchange</li> </ul>"},{"location":"architecture/#chapter-contents","title":"Chapter Contents","text":"<ul> <li>Dual-Layer Architecture - Dual-layer architecture, API nodes, streaming service nodes, and component interactions</li> <li>Core Concepts - System entities, role-based access control, and session behaviors</li> <li>Security Framework - Authorization framework, token-based authentication, and TCP streaming security</li> </ul>"},{"location":"architecture/#key-architectural-principles","title":"Key Architectural Principles","text":"Principle Implementation Separation of Concerns Distinct REST API and streaming layers Scalability Horizontal scaling, distributed architecture Security in Depth Multi-layer security model Operational Flexibility Configurable security levels, multiple tokens"},{"location":"architecture/core-concepts/","title":"Core Concepts","text":"<p>The Subject Interface is built on fundamental concepts that implementers must understand: the system entities, role-based access control, and session behaviors.</p>"},{"location":"architecture/core-concepts/#system-entities","title":"System Entities","text":"<p>The system is built on an entity-relationship model that governs access control, data ownership, and communication patterns:</p>"},{"location":"architecture/core-concepts/#account","title":"Account","text":"<ul> <li>Represents the identity of an authorization holder</li> <li>Can own multiple TLC registrations and authorizations</li> <li>Serves as the primary entity for access control and data ownership</li> <li>Enables individual or organizational control over interface resources</li> </ul>"},{"location":"architecture/core-concepts/#authorization","title":"Authorization","text":"<ul> <li>Defines permission to use the API through a combination of Account, Domain, and Role</li> <li>Establishes what actions can be performed and what data can be accessed</li> <li>Multiple authorizations can exist per account across different domains</li> <li>Forms the basis for role-based access control implementation</li> </ul>"},{"location":"architecture/core-concepts/#domain","title":"Domain","text":"<ul> <li>Defines the operational scope or jurisdiction to which an authorization applies</li> <li>Enables segmentation of access control across different geographical or organizational boundaries</li> <li>Supports multi-tenant deployments and jurisdictional separation</li> <li>Allows for hierarchical access management structures</li> </ul>"},{"location":"architecture/core-concepts/#tlc-registration","title":"TLC Registration","text":"<ul> <li>Represents the registration of any connected subject within a specific domain</li> <li>Despite the \"TLC\" naming, encompasses all types of connected entities</li> <li>Includes unique identification and configuration parameters for each subject</li> <li>Serves as the reference point for session management and data routing</li> </ul>"},{"location":"architecture/core-concepts/#authorizationtlc","title":"AuthorizationTLC","text":"<ul> <li>Defines the specific TLC scope for certain authorization types</li> <li>Only applicable to TLC_SYSTEM and TLC_ANALYST roles</li> <li>Enables fine-grained access control to specific subjects or groups of subjects</li> <li>Supports selective data access and operational permissions</li> </ul>"},{"location":"architecture/core-concepts/#authorizationtoken","title":"AuthorizationToken","text":"<ul> <li>The actual security token used for API authentication</li> <li>One authorization can have multiple active tokens for operational flexibility</li> <li>Enables token rotation and management without disrupting service</li> <li>Provides the mechanism for secure API access across all endpoints</li> </ul>"},{"location":"architecture/core-concepts/#role-based-access","title":"Role-Based Access","text":"<p>The Subject Interface implements a role-based access control system with three role categories, each having administrative, operational, and analytical variants.</p>"},{"location":"architecture/core-concepts/#role-categories","title":"Role Categories","text":"Category Purpose Typical Users Key Capabilities TLC Subject ownership and data generation Roadside equipment operators, central system administrators Direct control, data generation/transmission, session lifecycle, subject configuration BROKER Data distribution and routing Service providers, system integrators Multi-subject handling, value-added services, data aggregation, cross-domain operations MONITOR Data observation and analysis Monitoring platforms, research systems Read-only access, performance monitoring, analytics, compliance verification"},{"location":"architecture/core-concepts/#role-structure","title":"Role Structure","text":"Role Usage Primary Function TLC_ADMIN Administrative Manage subject registrations, authorizations, and tokens TLC_SYSTEM Operational Create/update sessions and stream data for assigned subjects TLC_ANALYST Diagnostics Monitor and analyze subject-specific data and sessions BROKER_ADMIN Administrative Manage broker service authorizations and configurations BROKER_SYSTEM Operational Create multiplex sessions and distribute data across subjects BROKER_ANALYST Diagnostics Monitor and analyze broker service performance and data flows MONITOR_ADMIN Administrative Manage monitoring service access and configurations MONITOR_SYSTEM Operational Create read-only sessions and receive data from multiple subjects MONITOR_ANALYST Diagnostics Analyze monitoring data and system performance trends"},{"location":"architecture/core-concepts/#session-behaviors","title":"Session Behaviors","text":"<p>The Subject Interface supports three session types that correspond to the role categories, each with distinct operational characteristics:</p> Session Type Created By Purpose Capabilities TLC Data owners/generators Production of information Full control over data streams and connection parameters BROKER Distribution systems Data routing and distribution Intermediary between producers and consumers, value-added services MONITOR Observation systems Data analysis and monitoring Read-only access, cannot modify or control streams <p>For technical implementation details including concurrency rules, data flow patterns, and protocol support, see Communication Modes.</p>"},{"location":"architecture/security-framework/","title":"Security Framework","text":"<p>The Subject Interface implements a multi-layer security framework covering authorization, authentication, and transport security.</p>"},{"location":"architecture/security-framework/#authorization-framework","title":"Authorization Framework","text":"<p>The authorization framework governs system access through an entity-relationship model supporting secure multi-tenant operations across domains and jurisdictions.</p>"},{"location":"architecture/security-framework/#core-authorization-entities","title":"Core Authorization Entities","text":"Entity Purpose Key Characteristics Account Identity holder (individual/organization) Owns multiple TLC registrations and authorizations; primary entity for permission assignment Authorization API permission definition Combines Account + Domain + Role; establishes security context for all operations Role Functional capabilities TLC (ownership), BROKER (distribution), MONITOR (observation); determines available endpoints Domain Operational scope/jurisdiction Geographic/organizational/project boundaries; complete data isolation TLC Subject registration 8-character identifier within domain; cornerstone for data routing and access control"},{"location":"architecture/security-framework/#authorization-entity-relationships","title":"Authorization Entity Relationships","text":"<p>The framework implements a carefully designed entity-relationship model:</p> <p></p>"},{"location":"architecture/security-framework/#key-relationships","title":"Key Relationships","text":"Relationship Cardinality Purpose Domain \u2194 TLC 1:\u221e Domain isolation, jurisdictional data separation Account \u2194 Authorization 1:\u221e Multi-domain operations, role separation Role \u2194 Authorization 1:\u221e Functional capability assignment Authorization \u2194 Token 1:\u221e Multiple active tokens, token rotation Authorization \u2194 TLC \u221e:\u221e Fine-grained access control (via AuthorizationTLC)"},{"location":"architecture/security-framework/#authorization-scope-levels","title":"Authorization Scope Levels","text":"Scope Access Level Applicable Roles Use Cases AuthorizationTLC Specific subjects within domain TLC_SYSTEM, TLC_ANALYST Device-specific access, regional restrictions, maintenance windows Domain-Level All resources in domain Domain admins, monitors, brokers Full domain access, subject discovery, bulk operations"},{"location":"architecture/security-framework/#token-based-authentication","title":"Token-Based Authentication","text":"<p>The Subject Interface uses a token-based authentication system for secure API access with operational flexibility and token lifecycle management.</p>"},{"location":"architecture/security-framework/#authorization-token-architecture","title":"Authorization Token Architecture","text":"Aspect Details Token Generation Generated for specific authorizations; multiple active tokens per authorization; cryptographically secure identifiers Lifecycle No expiration mechanism - remain valid until explicitly revoked Operational Benefits Multiple tokens prevent service disruption; security isolation; flexible deployment; audit granularity"},{"location":"architecture/security-framework/#token-structure","title":"Token Structure","text":"Component Details Format Base64url-encoded strings; cryptographically random; URL-safe Example <code>dtNB_vhvJ0wgTGf1N0DxN38_AmTL_4yiPRZdqZSuK3k</code> Metadata Unique UUID; linked to authorization"},{"location":"architecture/security-framework/#authentication-implementation","title":"Authentication Implementation","text":""},{"location":"architecture/security-framework/#http-header-authentication","title":"HTTP Header Authentication","text":"Specification Details Header Name <code>X-Authorization</code> (case-insensitive) Header Value Token string only, no prefixes (case-sensitive) Usage Required for all authenticated endpoints Example <code>X-Authorization: dtNB_vhvJ0wgTGf1N0DxN38_AmTL_4yiPRZdqZSuK3k</code>"},{"location":"architecture/security-framework/#token-lifecycle-management","title":"Token Lifecycle Management","text":""},{"location":"architecture/security-framework/#token-rotation","title":"Token Rotation","text":"Step Process 1. Create Create new token while old token remains active 2. Deploy Deploy new token to systems 3. Verify Verify new token functionality 4. Revoke Revoke old token 5. Complete Zero-downtime rotation completed"},{"location":"architecture/security-framework/#token-revocation","title":"Token Revocation","text":"Aspect Details Method DELETE request to <code>/authorizationtokens/{uuid}</code> Effect Instant invalidation; cannot be reversed; audit log entry created Scenario Use Case Security Incident Immediate revocation of compromised tokens Employee Departure Revoke associated tokens System Decommission Clean up unused tokens Regular Rotation Part of security maintenance"},{"location":"architecture/security-framework/#multi-token-strategies","title":"Multi-Token Strategies","text":"<p>Multiple tokens for the same authorization serve one primary purpose: token rotation. This allows creating a new token while the old token remains active, enabling zero-downtime rotation procedures.</p> <p>For system isolation and access control, use separate authorizations rather than multiple tokens. Each system or device should operate with its own authorization, even when roles and scope are identical.</p>"},{"location":"architecture/security-framework/#authorization-separation","title":"Authorization Separation","text":"Separation Type Recommendation Benefits System-Based One authorization per system/device Independent access control; isolated audit trails; simplified troubleshooting Environment-Based Separate authorizations for dev/staging/production Environment isolation; different access scopes; independent lifecycle management Functional-Based Separate authorizations per service function Service-specific permissions; granular access control; compliance boundaries"},{"location":"architecture/security-framework/#security-best-practices","title":"Security Best Practices","text":"Category Best Practices Storage Never store in source code; use secure credential management; encrypt at rest; limit access Transmission Always use HTTPS; never include in URLs; avoid logging values; secure configuration management Access Control Least-privilege principles; specific tokens for specific purposes; regular reviews; monitor usage Token Inventory Maintain registry; document purposes; track assignments; regular audits Incident Response Rapid revocation procedures; usage investigation; audit trail analysis; security protocols Monitoring Track failures; monitor unusual patterns; alert on suspicious activity; regular reviews"},{"location":"architecture/security-framework/#tcp-streaming-security","title":"TCP Streaming Security","text":"<p>The Subject Interface implements optional Transport Layer Security (TLS) for the TCP streaming protocol layer.</p> <p>Note: TLS configuration for the JSON-REST API layer is handled at the deployment level through standard web infrastructure components and is not covered in this specification.</p>"},{"location":"architecture/security-framework/#tls-implementation-specifications","title":"TLS Implementation Specifications","text":"Specification Details TLS Version TLS v1.2 exclusively; no older SSL/TLS versions; TLS v1.3 not currently supported Security Rationale Eliminates vulnerabilities; wide compatibility; balance between security and compatibility"},{"location":"architecture/security-framework/#supported-cipher-suite","title":"Supported Cipher Suite","text":"<p>Single cipher suite: <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code></p> Component Details Key Exchange ECDHE - Perfect forward secrecy; key generation Authentication RSA - Widely supported standard Encryption AES-128-GCM - Authenticated encryption; hardware acceleration support Hash SHA-256 - Message authentication; integrity verification"},{"location":"architecture/security-framework/#authentication-model","title":"Authentication Model","text":"Aspect Details TLS Handshake Standard handshake establishes encrypted channel; no client certificates required Session Authentication Handled via tokens after TLS establishment Server Certificate Valid period; proper key usage for server authentication"},{"location":"architecture/security-framework/#security-mode-configuration","title":"Security Mode Configuration","text":"<p>Security modes are configured during session creation via the REST API. The streaming protocol layer implements the security mode specified in the session configuration.</p>"},{"location":"architecture/security-framework/#see-also","title":"See Also","text":"<ul> <li>Create Session - POST /sessions endpoint for configuring security modes</li> <li>Communication Modes - Detailed security mode options and use cases</li> </ul>"},{"location":"architecture/system-architecture/","title":"Dual-Layer Architecture","text":"<p>The Subject Interface uses a dual-layer architecture that separates management operations from data streaming through specialized nodes.</p>"},{"location":"architecture/system-architecture/#overview","title":"Overview","text":"<p>The two components work together to provide a complete C-ITS communication solution:</p> <p></p>"},{"location":"architecture/system-architecture/#api-node","title":"API Node","text":"<p>The API Node implements the JSON-REST interface, providing lifecycle management and administrative control through web service endpoints.</p>"},{"location":"architecture/system-architecture/#core-characteristics","title":"Core Characteristics","text":"Characteristic Description Protocol JSON-REST principles Access Control Role-based permissions Management Resource lifecycle operations Multi-tenancy Cross-domain and jurisdiction support"},{"location":"architecture/system-architecture/#responsibilities-and-functions","title":"Responsibilities and Functions","text":"Function Purpose Operations Session Lifecycle Manage streaming sessions Session creation with protocol selection, real-time monitoring, dynamic updates, graceful termination Resource Management Handle CRUD operations Subject registrations, authorizations, tokens, accounts Authentication &amp; Authorization Secure access control Token validation, role-based access, scope restrictions, token relationships Administrative Monitoring System visibility and logs Historical session data, connection logs, system health status, diagnostic information Configuration Management System parameters Domain configuration, operational parameters, security settings, system limits"},{"location":"architecture/system-architecture/#interface-categories","title":"Interface Categories","text":"Category Purpose Capabilities ADMIN Interfaces Administrative control TLC registrations, authorization management, token generation/revocation, system configuration SYSTEM Interfaces Operational functionality Session creation/management, streaming control, real-time data exchange, connection monitoring Cross-Role Functionality Shared capabilities Dynamic subject discovery, load balancing, service distribution, domain-wide queries"},{"location":"architecture/system-architecture/#access-control-implementation","title":"Access Control Implementation","text":"Component Implementation Details Role-Based Validation Permission enforcement Verify roles, enforce boundaries, validate contexts, apply restrictions Scope Enforcement Multi-level access Platform (full system), Domain (domain-wide), Account (owned resources), Authorization (specific TLCs) Token Management Credential control Multiple active tokens, rotation without disruption, usage tracking, immediate revocation"},{"location":"architecture/system-architecture/#tcp-streaming-node","title":"TCP Streaming Node","text":"<p>The TCP Streaming Node implements the TCP streaming protocol, managing data exchange connections and providing low latency, high-volume communication.</p>"},{"location":"architecture/system-architecture/#core-characteristics_1","title":"Core Characteristics","text":"Characteristic Description Implementation Native TCP streaming with binary protocol Data Exchange Continuous asynchronous bidirectional streaming Payload Design Message-agnostic, supports any payload type Monitoring Built-in time synchronization and health tracking"},{"location":"architecture/system-architecture/#architecture-and-performance-features","title":"Architecture and Performance Features","text":"Feature Description Resilience Automatic recovery, fault tolerance, connection state persistence Horizontal Scalability Load balancing, stateless nodes, dynamic capacity adjustment Low Latency Real-time communication, minimal protocol overhead, direct TCP sockets High Throughput High-frequency messages, concurrent streams, backpressure handling Resource Optimization Memory utilization, bandwidth management, CPU optimization, connection pooling"},{"location":"architecture/system-architecture/#protocol-and-operational-features","title":"Protocol and Operational Features","text":"Feature Implementation Version Management Protocol negotiation at connect, future compatibility, graceful mismatch handling Frame-Based Communication Structured datagrams with integrity checking, fixed headers, variable payloads Time Synchronization Clock difference detection, regular timestamp exchanges, drift termination Security Integration Optional TLS v1.2, per-session configuration, token-based authentication"},{"location":"architecture/system-architecture/#core-responsibilities","title":"Core Responsibilities","text":"Function Purpose Operations Connection Management TCP connection handling Establishment procedures, keep-alive mechanisms, health monitoring, graceful termination Data Routing Payload distribution TLC to Broker routing, Broker to TLC distribution, Monitor replication, scope-based filtering Time Synchronization Timing enforcement Timestamp exchanges, clock difference calculations, drift detection, automatic enforcement Security Enforcement Policy application Token validation, session authentication, TLS encryption, access control verification Quality Monitoring Performance tracking Latency measurements, throughput statistics, error rate tracking, performance indicators Load Management Resource distribution Connection algorithms, utilization monitoring, automatic redistribution, capacity thresholds"},{"location":"examples/","title":"Multiplex TCP Streaming Example","text":"<p>This example demonstrates the complete Subject Interface v1 workflow, showcasing both the JSON-REST API layer for session management and the TCP Streaming Protocol layer for real-time data exchange. The implementation illustrates how clients interact with the dual-layer architecture to establish streaming sessions and exchange C-ITS messages.</p> <p>TLC Terminology</p> <p>The interface originally served Traffic Light Controllers (TLCs), and this legacy terminology persists in the API specifications for backward compatibility. \"TLC\" now refers to any connected entity: traffic controllers, sensors, barriers, displays, or any C-ITS participant. See Terminology Reference for the mapping between legacy and generic terminology.</p> <p>The example runs two concurrent sessions using the multiplex protocol:</p> <ul> <li>A TLC session representing a connected subject that produces data</li> <li>A Broker session acting as a data distribution hub that consumes and routes messages</li> </ul> <p>While this example shows a simplified scenario with the TLC session sending data and the Broker session receiving it, the Subject Interface supports full bi-directional communication. TLC sessions can receive data from Broker sessions, and Broker sessions can send data to TLC sessions.</p> <p>The implementation demonstrates the essential workflow: authenticating with the REST API, creating streaming sessions, establishing TCP connections to the Streaming Service Nodes, and exchanging framed messages using the protocol's datagram format.</p> <p>Important Disclaimer</p> <p>This example is for educational purposes only and is not production-ready. It demonstrates the basic workflow and protocol interaction but lacks the error handling, reconnection logic, monitoring, and robustness required for production deployments. Use this as a learning resource and starting point for understanding the Subject Interface v1.</p>"},{"location":"examples/#prerequisites","title":"Prerequisites","text":""},{"location":"examples/#general-requirements","title":"General Requirements","text":"<ul> <li>Valid authorization tokens for Subject Interface v1 API access</li> <li>Access to a Subject Interface v1 instance</li> <li>Network connectivity to both REST API and TCP streaming endpoints</li> </ul>"},{"location":"examples/#language-specific-requirements","title":"Language-Specific Requirements","text":"PythonGoRust.NET <ul> <li>Python 3.10 or later (uses match/case statements)</li> <li><code>requests</code> library for HTTP API calls</li> <li>Standard library modules (socket, ssl, struct, threading, json, logging)</li> </ul> <ul> <li>Go 1.21 or later</li> <li>Standard library modules (net/http, crypto/tls, encoding/binary, sync)</li> </ul> <ul> <li>Rust 1.83 or later</li> <li>Cargo dependencies: reqwest, serde, tokio, rustls, rand</li> </ul> <ul> <li>.NET 8.0 or later</li> <li>NuGet dependencies: Newtonsoft.Json</li> </ul>"},{"location":"examples/#configuration-by-environment","title":"Configuration by Environment","text":"<p>The example uses environment variables for configuration:</p> Variable Description Example <code>STREAMING_API_BASEURL</code> Base URL of the Subject Interface API <code>https://localhost/api</code> <code>STREAMING_API_TLC_TOKEN</code> Authorization token for TLC session <code>your-tlc-auth-token</code> <code>STREAMING_API_BROKER_TOKEN</code> Authorization token for Broker session <code>your-broker-auth-token</code> <code>STREAMING_API_DOMAIN</code> Domain for session creation <code>dev_001</code> <code>STREAMING_API_SECURITY_MODE</code> Security mode (<code>NONE</code> or <code>TLSv1.2</code>) <code>TLSv1.2</code> <code>STREAMING_API_IDENTIFIER</code> TLC identifier for payload messages <code>sub00001</code> PythonGoRust.NET <pre><code>STREAMING_API_BASEURL = os.environ.get(\"STREAMING_API_BASEURL\", \"https://localhost/api\")\nSTREAMING_API_TLC_TOKEN = os.environ.get(\"STREAMING_API_TLC_TOKEN\", \"your-tlc-auth-token\")\nSTREAMING_API_BROKER_TOKEN = os.environ.get(\"STREAMING_API_BROKER_TOKEN\", \"your-broker-auth-token\")\nSTREAMING_API_DOMAIN = os.environ.get(\"STREAMING_API_DOMAIN\", \"dev_001\")\nSTREAMING_API_SECURITY_MODE = os.environ.get(\"STREAMING_API_SECURITY_MODE\", \"TLSv1.2\")\nSTREAMING_API_IDENTIFIER = os.environ.get(\"STREAMING_API_IDENTIFIER\", \"sub00001\")\n</code></pre> <pre><code>var (\n    STREAMING_API_BASEURL      = getEnv(\"STREAMING_API_BASEURL\", \"https://localhost/api\")\n    STREAMING_API_TLC_TOKEN    = getEnv(\"STREAMING_API_TLC_TOKEN\", \"your-tlc-auth-token\")\n    STREAMING_API_BROKER_TOKEN = getEnv(\"STREAMING_API_BROKER_TOKEN\", \"your-broker-auth-token\")\n    STREAMING_API_DOMAIN       = getEnv(\"STREAMING_API_DOMAIN\", \"dev_001\")\n    STREAMING_API_SECURITY_MODE = getEnv(\"STREAMING_API_SECURITY_MODE\", \"TLSv1.2\")\n    STREAMING_API_IDENTIFIER   = getEnv(\"STREAMING_API_IDENTIFIER\", \"sub00001\")\n)\n</code></pre> <pre><code>fn get_env(key: &amp;str, default: &amp;str) -&gt; String {\n    env::var(key).unwrap_or_else(|_| default.to_string())\n}\n\nlazy_static::lazy_static! {\n    static ref STREAMING_API_BASEURL: String = get_env(\"STREAMING_API_BASEURL\", \"https://localhost/api\");\n    static ref STREAMING_API_TLC_TOKEN: String = get_env(\"STREAMING_API_TLC_TOKEN\", \"your-tlc-auth-token\");\n    static ref STREAMING_API_BROKER_TOKEN: String = get_env(\"STREAMING_API_BROKER_TOKEN\", \"your-broker-auth-token\");\n    static ref STREAMING_API_DOMAIN: String = get_env(\"STREAMING_API_DOMAIN\", \"dev_001\");\n    static ref STREAMING_API_SECURITY_MODE: String = get_env(\"STREAMING_API_SECURITY_MODE\", \"TLSv1.2\");\n    static ref STREAMING_API_IDENTIFIER: String = get_env(\"STREAMING_API_IDENTIFIER\", \"sub00001\");\n}\n</code></pre> <pre><code>public static class Config\n{\n    public static string StreamingApiBaseUrl { get; } = Environment.GetEnvironmentVariable(\"STREAMING_API_BASEURL\") ?? \"https://localhost/api\";\n    public static string StreamingApiTlcToken { get; } = Environment.GetEnvironmentVariable(\"STREAMING_API_TLC_TOKEN\") ?? \"your-tlc-auth-token\";\n    public static string StreamingApiBrokerToken { get; } = Environment.GetEnvironmentVariable(\"STREAMING_API_BROKER_TOKEN\") ?? \"your-broker-auth-token\";\n    public static string StreamingApiDomain { get; } = Environment.GetEnvironmentVariable(\"STREAMING_API_DOMAIN\") ?? \"dev_001\";\n    public static string StreamingApiSecurityMode { get; } = Environment.GetEnvironmentVariable(\"STREAMING_API_SECURITY_MODE\") ?? \"TLSv1.2\";\n    public static string StreamingApiIdentifier { get; } = Environment.GetEnvironmentVariable(\"STREAMING_API_IDENTIFIER\") ?? \"sub00001\";\n}\n</code></pre>"},{"location":"examples/#rest-api-client-functions","title":"REST API Client Functions","text":"<p>The REST API client creates sessions for both TLC and Broker types:</p> PythonGoRust.NET <pre><code>def create_session(type, token, api_url, security_mode, identifier): \n    url = f\"{api_url}/v1/sessions\"\n    headers = {\n        'X-Authorization': f\"{token}\",\n        'Content-Type': 'application/json'\n    }\n\n    data = {\n        \"domain\": f\"{STREAMING_API_DOMAIN}\",\n        \"type\": type,\n        \"protocol\": \"TCPStreaming_Multiplex\",\n        \"details\": {\n            \"securityMode\": security_mode,\n            \"tlcIdentifiers\": [identifier]\n        }\n    }\n\n    response = requests.post(url, headers=headers, json=data)\n\n    if response.ok:\n        response_data = response.json()\n        log_json(\"Session created successfully\", response_data)\n        token = response_data.get('token')\n        host = response_data['details']['listener']['host']\n        port = response_data['details']['listener']['port']\n        log(f\"Token: {token}\")\n        log(f\"Host: {host}\")\n        log(f\"Port: {port}\")\n        return host, port, token\n    else:\n        log(f\"Request failed with status code {response.status_code}\")\n</code></pre> <pre><code>func createSession(sessionType, token, apiURL, securityMode, identifier, threadName string) (string, int, string, error) {\n    url := fmt.Sprintf(\"%s/v1/sessions\", apiURL)\n\n    requestData := map[string]interface{}{\n        \"domain\":   STREAMING_API_DOMAIN,\n        \"type\":     sessionType,\n        \"protocol\": \"TCPStreaming_Multiplex\",\n        \"details\": map[string]interface{}{\n            \"securityMode\":   securityMode,\n            \"tlcIdentifiers\": []string{identifier},\n        },\n    }\n\n    jsonData, err := json.Marshal(requestData)\n    if err != nil {\n        return \"\", 0, \"\", fmt.Errorf(\"failed to marshal request data: %v\", err)\n    }\n\n    req, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonData))\n    if err != nil {\n        return \"\", 0, \"\", fmt.Errorf(\"failed to create request: %v\", err)\n    }\n\n    req.Header.Set(\"X-Authorization\", token)\n    req.Header.Set(\"Content-Type\", \"application/json\")\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return \"\", 0, \"\", fmt.Errorf(\"request failed: %v\", err)\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return \"\", 0, \"\", fmt.Errorf(\"request failed with status code %d\", resp.StatusCode)\n    }\n\n    var responseData map[string]interface{}\n    if err := json.NewDecoder(resp.Body).Decode(&amp;responseData); err != nil {\n        return \"\", 0, \"\", fmt.Errorf(\"failed to decode response: %v\", err)\n    }\n\n    logJSON(threadName, \"Session created successfully\", responseData)\n\n    sessionToken := responseData[\"token\"].(string)\n    host := responseData[\"details\"].(map[string]interface{})[\"listener\"].(map[string]interface{})[\"host\"].(string)\n    port := int(responseData[\"details\"].(map[string]interface{})[\"listener\"].(map[string]interface{})[\"port\"].(float64))\n\n    logMsg(threadName, fmt.Sprintf(\"Token: %s\", sessionToken))\n    logMsg(threadName, fmt.Sprintf(\"Host: %s\", host))\n    logMsg(threadName, fmt.Sprintf(\"Port: %d\", port))\n\n    return host, port, sessionToken, nil\n}\n</code></pre> <pre><code>#[derive(Serialize)]\nstruct SessionRequest {\n    domain: String,\n    #[serde(rename = \"type\")]\n    session_type: String,\n    protocol: String,\n    details: SessionDetails,\n}\n\n#[derive(Serialize)]\nstruct SessionDetails {\n    #[serde(rename = \"securityMode\")]\n    security_mode: String,\n    #[serde(rename = \"tlcIdentifiers\")]\n    tlc_identifiers: Vec&lt;String&gt;,\n}\n\n#[derive(Deserialize)]\nstruct SessionResponse {\n    token: String,\n    details: SessionResponseDetails,\n}\n\n#[derive(Deserialize)]\nstruct SessionResponseDetails {\n    listener: ListenerDetails,\n}\n\n#[derive(Deserialize)]\nstruct ListenerDetails {\n    host: String,\n    port: u16,\n}\n\nasync fn create_session(\n    session_type: &amp;str,\n    token: &amp;str,\n    api_url: &amp;str,\n    security_mode: &amp;str,\n    identifier: &amp;str,\n    thread_name: &amp;str,\n) -&gt; Result&lt;(String, u16, String), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    let url = format!(\"{}/v1/sessions\", api_url);\n\n    let request_data = SessionRequest {\n        domain: STREAMING_API_DOMAIN.clone(),\n        session_type: session_type.to_string(),\n        protocol: \"TCPStreaming_Multiplex\".to_string(),\n        details: SessionDetails {\n            security_mode: security_mode.to_string(),\n            tlc_identifiers: vec![identifier.to_string()],\n        },\n    };\n\n    let client = reqwest::Client::new();\n    let response = client\n        .post(&amp;url)\n        .header(\"X-Authorization\", token)\n        .header(\"Content-Type\", \"application/json\")\n        .json(&amp;request_data)\n        .send()\n        .await?;\n\n    if !response.status().is_success() {\n        return Err(format!(\"Request failed with status code {}\", response.status()).into());\n    }\n\n    let response_data: Value = response.json().await?;\n    log_json(thread_name, \"Session created successfully\", &amp;response_data);\n\n    let session_response: SessionResponse = serde_json::from_value(response_data)?;\n\n    log_msg(thread_name, &amp;format!(\"Token: {}\", session_response.token));\n    log_msg(thread_name, &amp;format!(\"Host: {}\", session_response.details.listener.host));\n    log_msg(thread_name, &amp;format!(\"Port: {}\", session_response.details.listener.port));\n\n    Ok((\n        session_response.details.listener.host,\n        session_response.details.listener.port,\n        session_response.token,\n    ))\n}\n</code></pre> <pre><code>public class SessionRequest\n{\n    [JsonProperty(\"domain\")]\n    public string Domain { get; set; } = \"\";\n\n    [JsonProperty(\"type\")]\n    public string Type { get; set; } = \"\";\n\n    [JsonProperty(\"protocol\")]\n    public string Protocol { get; set; } = \"\";\n\n    [JsonProperty(\"details\")]\n    public SessionDetails Details { get; set; } = new();\n}\n\npublic class SessionDetails\n{\n    [JsonProperty(\"securityMode\")]\n    public string SecurityMode { get; set; } = \"\";\n\n    [JsonProperty(\"tlcIdentifiers\")]\n    public List&lt;string&gt; TlcIdentifiers { get; set; } = new();\n}\n\npublic class SessionResponse\n{\n    [JsonProperty(\"token\")]\n    public string Token { get; set; } = \"\";\n\n    [JsonProperty(\"details\")]\n    public SessionResponseDetails Details { get; set; } = new();\n}\n\npublic class SessionResponseDetails\n{\n    [JsonProperty(\"listener\")]\n    public ListenerDetails Listener { get; set; } = new();\n}\n\npublic class ListenerDetails\n{\n    [JsonProperty(\"host\")]\n    public string Host { get; set; } = \"\";\n\n    [JsonProperty(\"port\")]\n    public int Port { get; set; }\n}\n\npublic static class RestApi\n{\n    private static readonly HttpClient httpClient = new();\n\n    public static async Task&lt;(string host, int port, string token)&gt; CreateSessionAsync(\n        string sessionType, \n        string token, \n        string apiUrl, \n        string securityMode, \n        string identifier, \n        string threadName)\n    {\n        var url = $\"{apiUrl}/v1/sessions\";\n\n        var requestData = new SessionRequest\n        {\n            Domain = Config.StreamingApiDomain,\n            Type = sessionType,\n            Protocol = \"TCPStreaming_Multiplex\",\n            Details = new SessionDetails\n            {\n                SecurityMode = securityMode,\n                TlcIdentifiers = new List&lt;string&gt; { identifier }\n            }\n        };\n\n        var json = JsonConvert.SerializeObject(requestData);\n        var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n        var request = new HttpRequestMessage(HttpMethod.Post, url)\n        {\n            Content = content\n        };\n        request.Headers.Add(\"X-Authorization\", token);\n\n        var response = await httpClient.SendAsync(request);\n\n        if (!response.IsSuccessStatusCode)\n        {\n            throw new HttpRequestException($\"Request failed with status code {response.StatusCode}\");\n        }\n\n        var responseJson = await response.Content.ReadAsStringAsync();\n        var responseData = JsonConvert.DeserializeObject&lt;object&gt;(responseJson);\n        Utilities.LogJson(threadName, \"Session created successfully\", responseData!);\n\n        var sessionResponse = JsonConvert.DeserializeObject&lt;SessionResponse&gt;(responseJson);\n        if (sessionResponse == null)\n        {\n            throw new InvalidOperationException(\"Failed to deserialize session response\");\n        }\n\n        Utilities.LogMessage(threadName, $\"Token: {sessionResponse.Token}\");\n        Utilities.LogMessage(threadName, $\"Host: {sessionResponse.Details.Listener.Host}\");\n        Utilities.LogMessage(threadName, $\"Port: {sessionResponse.Details.Listener.Port}\");\n\n        return (sessionResponse.Details.Listener.Host, sessionResponse.Details.Listener.Port, sessionResponse.Token);\n    }\n}\n</code></pre> <p>Explanation</p> PythonGoRust.NET <p>The <code>create_session</code> function creates either a TLC or Broker session with multiplex protocol support. It returns the TCP streaming endpoint details (host, port) and session token for authentication.</p> <p>The <code>createSession</code> function creates either a TLC or Broker session with multiplex protocol support. It returns the TCP streaming endpoint details (host, port) and session token for authentication.</p> <p>The <code>create_session</code> function creates either a TLC or Broker session with multiplex protocol support. It returns the TCP streaming endpoint details (host, port) and session token for authentication.</p> <p>The <code>CreateSessionAsync</code> function creates either a TLC or Broker session with multiplex protocol support. It returns the TCP streaming endpoint details (host, port) and session token for authentication.</p>"},{"location":"examples/#tcp-streaming-client-functions","title":"TCP Streaming Client Functions","text":"<p>The TCP streaming client handles the multiplex protocol communication:</p> PythonGoRust.NET <pre><code>def connect(host, port, tls):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((host, port))\n\n    log(f\"Connected to {host}:{port} (TLS: {tls})\")\n\n    if tls:\n        # Wrap the socket in an SSL context and perform the TLS handshake\n        sslsock = SSL_CONTEXT.wrap_socket(sock, server_hostname=host)\n        sslsock.do_handshake()\n\n        peer_name = sslsock.getpeername()\n        peer_cert = sslsock.getpeercert()\n        (cipher_name, cipher_version, cipher_bits) = sslsock.cipher()\n\n        log(f\"TLS handshake successful - Peer: {peer_name}, Certificate: {peer_cert}, Cipher: {cipher_name} {cipher_version} {cipher_bits} bits\")\n\n        return sslsock\n    else:\n        return sock\n\n\ndef handshake(sock):\n    protocol_version_byte = b'\\x01'\n    sock.setblocking(True)\n    sock.sendall(protocol_version_byte)\n    recv = sock.recv(1)\n    log(f\"Received protocol version {as_hexstream(recv)}\")\n    if recv[0] != 1:\n        raise Exception(\"Unsupported protocol version received\")\n\n\ndef write_datagram(sock, datagram):\n    datagram_size = len(datagram).to_bytes(2, 'big')\n    header = HEADER_PREFIX + datagram_size\n    frame = header + datagram\n    log(f\"Writing frame {as_hexstream(frame)}\")\n    sock.setblocking(True)\n    sock.sendall(frame)\n\n\ndef write_token(sock, token):\n    log(f\"Writing token {token}\")\n    datagram_type = b'\\x01'\n    data = token.encode('ascii')\n    datagram = datagram_type + data\n    write_datagram(sock, datagram)\n\n\ndef write_keepalive(sock):\n    log(\"Writing keep alive\")\n    datagram_type = b'\\x00'\n    data = b''\n    datagram = datagram_type + data\n    write_datagram(sock, datagram)\n\n\ndef write_timestamp_response(sock, timestamp_t0, timestamp_t1):\n    timestamp_t2 = current_timestamp()\n    log(f\"Writing timestamp response (t0: {timestamp_t0}, t1: {timestamp_t1}, t2: {timestamp_t2})\")\n    datagram = struct.pack(\"&gt;cQQQ\", b'\\x07', timestamp_t0, timestamp_t1, timestamp_t2)\n    write_datagram(sock, datagram)\n\n\ndef write_payload_with_identifier(sock, identifier, payload_type, payload):\n    log(f\"Writing payload with identifier (identifier: {identifier}, payload_type: {as_hexstream(struct.pack('B', payload_type))}): {as_hexstream(payload)}\")\n    datagram = b'\\x05' + bytes(identifier, 'ascii') + struct.pack(\"&gt;BQ\", payload_type, current_timestamp()) + payload\n    write_datagram(sock, datagram)\n\n\ndef read_datagram(sock):\n    sock.setblocking(False)\n    try:\n        header = sock.recv(4)\n    except ssl.SSLWantReadError:\n        # SSLSocket is not ready for reading, return None.\n        return None\n    except socket.error as e:\n        if e.errno == errno.EAGAIN or e.errno == errno.EWOULDBLOCK:\n            # No error, but socket is not ready for reading.\n            return None\n        else:\n            raise e\n    else:\n        if len(header) == 0:\n            raise Exception(\"Socked disconnected\")\n        log(f\"Received header {as_hexstream(header)}\")\n        if len(header) != 4:\n            raise Exception(\"Received partial header (implementation does not support partial receives yet)\")\n        prefix = header[0:2]\n        if prefix != HEADER_PREFIX:\n            raise Exception(f\"Framing error: header prefix {as_hexstream(prefix)} != {as_hexstream(HEADER_PREFIX)}\")\n        size = struct.unpack(\"&gt;H\", header[2:4])[0]\n        log(f\"Trying to read {size} bytes datagram\")\n        sock.setblocking(True)\n        datagram = sock.recv(size)\n        log(f\"Received datagram {as_hexstream(datagram)}\")\n        if len(datagram) != size:\n            raise Exception(\"Received partial datagram (implementation does not support partial receives yet)\")\n        return datagram\n\n\ndef handle_keepalive(sock):\n    log(\"Keep alive received\")\n\n\ndef handle_bye(sock, datagram):\n    log(\"Bye received\")\n    reason = datagram[1:]\n    log(f\"Bye reason: {reason}\")\n\n\ndef handle_payload_with_identifier(sock, datagram, payload_received_callback):\n    log(\"Payload with identifier received\")\n    identifier = datagram[1:9].decode('ascii')\n    payload_type = datagram[9:10][0]\n    origin_timestamp = struct.unpack(\"&gt;Q\", datagram[10:18])[0]\n    payload = datagram[18:]\n    log(f\"Payload received (identifier: {identifier}, payload_type: {as_hexstream(struct.pack('B', payload_type))}, origin_timestamp: {origin_timestamp}): {as_hexstream(payload)}\")\n    payload_received_callback(identifier, payload_type, origin_timestamp, payload)\n\n\ndef handle_timestamp_request(sock, datagram):\n    log(\"Timestamp request received\")\n    timestamp_t0 = struct.unpack(\"&gt;Q\", datagram[1:])[0]\n    timestamp_t1 = current_timestamp()\n    log(f\"Timestamp request delta: {timestamp_t1 - timestamp_t0}ms\")\n    write_timestamp_response(sock, timestamp_t0, timestamp_t1)\n\n\ndef handle_datagram(sock, datagram, payload_received_callback):\n    datagram_type = datagram[0:1]\n    match datagram_type:\n        case b'\\x00':\n            handle_keepalive(sock)\n        case b'\\x02':\n            handle_bye(sock, datagram)\n        case b'\\x05':\n            handle_payload_with_identifier(sock, datagram, payload_received_callback)\n        case b'\\x06':\n            handle_timestamp_request(sock, datagram)\n        case _:\n            log(f\"Unknown/unimplemented datagram type {as_hexstream(datagram_type)} received\")\n\n\ndef run_streaming_client(host, port, session_token, tls, payload_received_callback, loop_callback):\n    sock = connect(host, port, tls)\n\n    try:\n        handshake(sock)\n        write_token(sock, session_token)\n\n        while True:\n            datagram = read_datagram(sock)\n            if datagram:\n                handle_datagram(sock, datagram, payload_received_callback)\n            else:\n                time.sleep(0.01)\n\n            loop_callback(sock)\n\n    finally:\n        sock.close()\n</code></pre> <pre><code>func connect(host string, port int, useTLS bool, threadName string) (net.Conn, error) {\n    address := fmt.Sprintf(\"%s:%d\", host, port)\n\n    if useTLS {\n        config := &amp;tls.Config{\n            ServerName: host,\n        }\n        conn, err := tls.Dial(\"tcp\", address, config)\n        if err != nil {\n            return nil, fmt.Errorf(\"TLS connection failed: %v\", err)\n        }\n\n        logMsg(threadName, fmt.Sprintf(\"Connected to %s:%d (TLS: %t)\", host, port, useTLS))\n\n        // Log TLS connection details\n        state := conn.ConnectionState()\n        logMsg(threadName, fmt.Sprintf(\"TLS handshake successful - Version: %x, Cipher: %x\", state.Version, state.CipherSuite))\n\n        return conn, nil\n    } else {\n        conn, err := net.Dial(\"tcp\", address)\n        if err != nil {\n            return nil, fmt.Errorf(\"TCP connection failed: %v\", err)\n        }\n\n        logMsg(threadName, fmt.Sprintf(\"Connected to %s:%d (TLS: %t)\", host, port, useTLS))\n        return conn, nil\n    }\n}\n\nfunc handshake(conn net.Conn, threadName string) error {\n    protocolVersionByte := []byte{0x01}\n    _, err := conn.Write(protocolVersionByte)\n    if err != nil {\n        return fmt.Errorf(\"failed to send protocol version: %v\", err)\n    }\n\n    recv := make([]byte, 1)\n    _, err = io.ReadFull(conn, recv)\n    if err != nil {\n        return fmt.Errorf(\"failed to receive protocol version: %v\", err)\n    }\n\n    logMsg(threadName, fmt.Sprintf(\"Received protocol version %s\", asHexStream(recv)))\n\n    if recv[0] != 1 {\n        return fmt.Errorf(\"unsupported protocol version received\")\n    }\n\n    return nil\n}\n\nfunc writeDatagram(conn net.Conn, datagram []byte, threadName string) error {\n    datagramSize := make([]byte, 2)\n    binary.BigEndian.PutUint16(datagramSize, uint16(len(datagram)))\n\n    header := append(HEADER_PREFIX, datagramSize...)\n    frame := append(header, datagram...)\n\n    logMsg(threadName, fmt.Sprintf(\"Writing frame %s\", asHexStream(frame)))\n\n    _, err := conn.Write(frame)\n    return err\n}\n\nfunc writeToken(conn net.Conn, token, threadName string) error {\n    logMsg(threadName, fmt.Sprintf(\"Writing token %s\", token))\n    datagramType := []byte{0x01}\n    data := []byte(token)\n    datagram := append(datagramType, data...)\n    return writeDatagram(conn, datagram, threadName)\n}\n\nfunc writeKeepalive(conn net.Conn, threadName string) error {\n    logMsg(threadName, \"Writing keep alive\")\n    datagramType := []byte{0x00}\n    data := []byte{}\n    datagram := append(datagramType, data...)\n    return writeDatagram(conn, datagram, threadName)\n}\n\nfunc writeTimestampResponse(conn net.Conn, timestampT0, timestampT1 int64, threadName string) error {\n    timestampT2 := currentTimestamp()\n    logMsg(threadName, fmt.Sprintf(\"Writing timestamp response (t0: %d, t1: %d, t2: %d)\", timestampT0, timestampT1, timestampT2))\n\n    datagram := make([]byte, 25)\n    datagram[0] = 0x07\n    binary.BigEndian.PutUint64(datagram[1:9], uint64(timestampT0))\n    binary.BigEndian.PutUint64(datagram[9:17], uint64(timestampT1))\n    binary.BigEndian.PutUint64(datagram[17:25], uint64(timestampT2))\n\n    return writeDatagram(conn, datagram, threadName)\n}\n\nfunc writePayloadWithIdentifier(conn net.Conn, identifier string, payloadType byte, payload []byte, threadName string) error {\n    logMsg(threadName, fmt.Sprintf(\"Writing payload with identifier (identifier: %s, payload_type: %s): %s\", \n        identifier, asHexStream([]byte{payloadType}), asHexStream(payload)))\n\n    datagram := []byte{0x05}\n    datagram = append(datagram, []byte(identifier)...)\n\n    // Add payload type and timestamp\n    payloadTypeAndTimestamp := make([]byte, 9)\n    payloadTypeAndTimestamp[0] = payloadType\n    binary.BigEndian.PutUint64(payloadTypeAndTimestamp[1:9], uint64(currentTimestamp()))\n    datagram = append(datagram, payloadTypeAndTimestamp...)\n    datagram = append(datagram, payload...)\n\n    return writeDatagram(conn, datagram, threadName)\n}\n\nfunc readDatagram(conn net.Conn, threadName string) ([]byte, error) {\n    // Set read timeout for non-blocking behavior\n    conn.SetReadDeadline(time.Now().Add(10 * time.Millisecond))\n\n    header := make([]byte, 4)\n    n, err := io.ReadFull(conn, header)\n    if err != nil {\n        if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() {\n            return nil, nil // No data available, return nil\n        }\n        if err == io.EOF {\n            return nil, fmt.Errorf(\"socket disconnected\")\n        }\n        return nil, err\n    }\n\n    if n == 0 {\n        return nil, fmt.Errorf(\"socket disconnected\")\n    }\n\n    logMsg(threadName, fmt.Sprintf(\"Received header %s\", asHexStream(header)))\n\n    if n != 4 {\n        return nil, fmt.Errorf(\"received partial header (implementation does not support partial receives yet)\")\n    }\n\n    prefix := header[0:2]\n    if !bytes.Equal(prefix, HEADER_PREFIX) {\n        return nil, fmt.Errorf(\"framing error: header prefix %s != %s\", asHexStream(prefix), asHexStream(HEADER_PREFIX))\n    }\n\n    size := binary.BigEndian.Uint16(header[2:4])\n    logMsg(threadName, fmt.Sprintf(\"Trying to read %d bytes datagram\", size))\n\n    // Remove timeout for reading the full datagram\n    conn.SetReadDeadline(time.Time{})\n    datagram := make([]byte, size)\n    n, err = io.ReadFull(conn, datagram)\n    if err != nil {\n        return nil, err\n    }\n\n    logMsg(threadName, fmt.Sprintf(\"Received datagram %s\", asHexStream(datagram)))\n\n    if n != int(size) {\n        return nil, fmt.Errorf(\"received partial datagram (implementation does not support partial receives yet)\")\n    }\n\n    return datagram, nil\n}\n\nfunc handleKeepalive(conn net.Conn, threadName string) {\n    logMsg(threadName, \"Keep alive received\")\n}\n\nfunc handleBye(conn net.Conn, datagram []byte, threadName string) {\n    logMsg(threadName, \"Bye received\")\n    reason := datagram[1:]\n    logMsg(threadName, fmt.Sprintf(\"Bye reason: %s\", string(reason)))\n}\n\nfunc handlePayloadWithIdentifier(conn net.Conn, datagram []byte, payloadReceivedCallback func(string, byte, int64, []byte), threadName string) {\n    logMsg(threadName, \"Payload with identifier received\")\n    identifier := string(datagram[1:9])\n    payloadType := datagram[9]\n    originTimestamp := int64(binary.BigEndian.Uint64(datagram[10:18]))\n    payload := datagram[18:]\n\n    logMsg(threadName, fmt.Sprintf(\"Payload received (identifier: %s, payload_type: %s, origin_timestamp: %d): %s\", \n        identifier, asHexStream([]byte{payloadType}), originTimestamp, asHexStream(payload)))\n\n    payloadReceivedCallback(identifier, payloadType, originTimestamp, payload)\n}\n\nfunc handleTimestampRequest(conn net.Conn, datagram []byte, threadName string) {\n    logMsg(threadName, \"Timestamp request received\")\n    timestampT0 := int64(binary.BigEndian.Uint64(datagram[1:]))\n    timestampT1 := currentTimestamp()\n    logMsg(threadName, fmt.Sprintf(\"Timestamp request delta: %dms\", timestampT1-timestampT0))\n    writeTimestampResponse(conn, timestampT0, timestampT1, threadName)\n}\n\nfunc handleDatagram(conn net.Conn, datagram []byte, payloadReceivedCallback func(string, byte, int64, []byte), threadName string) {\n    datagramType := datagram[0]\n\n    switch datagramType {\n    case 0x00:\n        handleKeepalive(conn, threadName)\n    case 0x02:\n        handleBye(conn, datagram, threadName)\n    case 0x05:\n        handlePayloadWithIdentifier(conn, datagram, payloadReceivedCallback, threadName)\n    case 0x06:\n        handleTimestampRequest(conn, datagram, threadName)\n    default:\n        logMsg(threadName, fmt.Sprintf(\"Unknown/unimplemented datagram type %s received\", asHexStream([]byte{datagramType})))\n    }\n}\n\nfunc runStreamingClient(host string, port int, sessionToken string, useTLS bool, payloadReceivedCallback func(string, byte, int64, []byte), loopCallback func(net.Conn), threadName string) error {\n    conn, err := connect(host, port, useTLS, threadName)\n    if err != nil {\n        return err\n    }\n    defer conn.Close()\n\n    if err := handshake(conn, threadName); err != nil {\n        return err\n    }\n\n    if err := writeToken(conn, sessionToken, threadName); err != nil {\n        return err\n    }\n\n    for {\n        datagram, err := readDatagram(conn, threadName)\n        if err != nil {\n            return err\n        }\n\n        if datagram != nil {\n            handleDatagram(conn, datagram, payloadReceivedCallback, threadName)\n        } else {\n            time.Sleep(10 * time.Millisecond)\n        }\n\n        loopCallback(conn)\n    }\n}\n</code></pre> <pre><code>enum Connection {\n    Plain(TcpStream),\n    Tls(TlsStream&lt;TcpStream&gt;),\n}\n\nimpl Connection {\n    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {\n        match self {\n            Connection::Plain(stream) =&gt; stream.read(buf),\n            Connection::Tls(stream) =&gt; stream.read(buf),\n        }\n    }\n\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; std::io::Result&lt;usize&gt; {\n        match self {\n            Connection::Plain(stream) =&gt; stream.write(buf),\n            Connection::Tls(stream) =&gt; stream.write(buf),\n        }\n    }\n\n    fn set_nonblocking(&amp;self, nonblocking: bool) -&gt; std::io::Result&lt;()&gt; {\n        match self {\n            Connection::Plain(stream) =&gt; stream.set_nonblocking(nonblocking),\n            Connection::Tls(stream) =&gt; stream.get_ref().set_nonblocking(nonblocking),\n        }\n    }\n}\n\nfn connect(host: &amp;str, port: u16, use_tls: bool, thread_name: &amp;str) -&gt; Result&lt;Connection, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    let stream = TcpStream::connect(format!(\"{}:{}\", host, port))?;\n\n    if use_tls {\n        let connector = TlsConnector::new()?;\n        let tls_stream = connector.connect(host, stream)?;\n\n        log_msg(thread_name, &amp;format!(\"Connected to {}:{} (TLS: {})\", host, port, use_tls));\n        log_msg(thread_name, \"TLS handshake successful\");\n\n        Ok(Connection::Tls(tls_stream))\n    } else {\n        log_msg(thread_name, &amp;format!(\"Connected to {}:{} (TLS: {})\", host, port, use_tls));\n        Ok(Connection::Plain(stream))\n    }\n}\n\nfn handshake(conn: &amp;mut Connection, thread_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    let protocol_version_byte = [0x01];\n    conn.write(&amp;protocol_version_byte)?;\n\n    let mut recv = [0u8; 1];\n    conn.read(&amp;mut recv)?;\n\n    log_msg(thread_name, &amp;format!(\"Received protocol version {}\", as_hex_stream(&amp;recv)));\n\n    if recv[0] != 1 {\n        return Err(\"Unsupported protocol version received\".into());\n    }\n\n    Ok(())\n}\n\nfn write_datagram(conn: &amp;mut Connection, datagram: &amp;[u8], thread_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    let mut header = Vec::new();\n    header.extend_from_slice(&amp;HEADER_PREFIX);\n    header.extend_from_slice(&amp;(datagram.len() as u16).to_be_bytes());\n\n    let mut frame = header;\n    frame.extend_from_slice(datagram);\n\n    log_msg(thread_name, &amp;format!(\"Writing frame {}\", as_hex_stream(&amp;frame)));\n\n    conn.write(&amp;frame)?;\n    Ok(())\n}\n\nfn write_token(conn: &amp;mut Connection, token: &amp;str, thread_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    log_msg(thread_name, &amp;format!(\"Writing token {}\", token));\n    let mut datagram = vec![0x01];\n    datagram.extend_from_slice(token.as_bytes());\n    write_datagram(conn, &amp;datagram, thread_name)\n}\n\nfn write_keepalive(conn: &amp;mut Connection, thread_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    log_msg(thread_name, \"Writing keep alive\");\n    let datagram = [0x00];\n    write_datagram(conn, &amp;datagram, thread_name)\n}\n\nfn write_timestamp_response(\n    conn: &amp;mut Connection,\n    timestamp_t0: u64,\n    timestamp_t1: u64,\n    thread_name: &amp;str,\n) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    let timestamp_t2 = current_timestamp();\n    log_msg(\n        thread_name,\n        &amp;format!(\"Writing timestamp response (t0: {}, t1: {}, t2: {})\", timestamp_t0, timestamp_t1, timestamp_t2),\n    );\n\n    let mut datagram = vec![0x07];\n    datagram.extend_from_slice(&amp;timestamp_t0.to_be_bytes());\n    datagram.extend_from_slice(&amp;timestamp_t1.to_be_bytes());\n    datagram.extend_from_slice(&amp;timestamp_t2.to_be_bytes());\n\n    write_datagram(conn, &amp;datagram, thread_name)\n}\n\nfn write_payload_with_identifier(\n    conn: &amp;mut Connection,\n    identifier: &amp;str,\n    payload_type: u8,\n    payload: &amp;[u8],\n    thread_name: &amp;str,\n) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    log_msg(\n        thread_name,\n        &amp;format!(\n            \"Writing payload with identifier (identifier: {}, payload_type: {}): {}\",\n            identifier,\n            as_hex_stream(&amp;[payload_type]),\n            as_hex_stream(payload)\n        ),\n    );\n\n    let mut datagram = vec![0x05];\n    datagram.extend_from_slice(identifier.as_bytes());\n    datagram.push(payload_type);\n    datagram.extend_from_slice(&amp;current_timestamp().to_be_bytes());\n    datagram.extend_from_slice(payload);\n\n    write_datagram(conn, &amp;datagram, thread_name)\n}\n\nfn read_datagram(conn: &amp;mut Connection, thread_name: &amp;str) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    conn.set_nonblocking(true)?;\n\n    let mut header = [0u8; 4];\n    match conn.read(&amp;mut header) {\n        Ok(0) =&gt; return Err(\"Socket disconnected\".into()),\n        Ok(n) if n != 4 =&gt; return Err(\"Received partial header (implementation does not support partial receives yet)\".into()),\n        Ok(_) =&gt; {},\n        Err(e) if e.kind() == std::io::ErrorKind::WouldBlock =&gt; return Ok(None),\n        Err(e) =&gt; return Err(e.into()),\n    }\n\n    log_msg(thread_name, &amp;format!(\"Received header {}\", as_hex_stream(&amp;header)));\n\n    if header[0..2] != HEADER_PREFIX {\n        return Err(format!(\"Framing error: header prefix {} != {}\", \n                          as_hex_stream(&amp;header[0..2]), \n                          as_hex_stream(&amp;HEADER_PREFIX)).into());\n    }\n\n    let size = u16::from_be_bytes([header[2], header[3]]) as usize;\n    log_msg(thread_name, &amp;format!(\"Trying to read {} bytes datagram\", size));\n\n    conn.set_nonblocking(false)?;\n    let mut datagram = vec![0u8; size];\n    conn.read(&amp;mut datagram)?;\n\n    log_msg(thread_name, &amp;format!(\"Received datagram {}\", as_hex_stream(&amp;datagram)));\n\n    Ok(Some(datagram))\n}\n\nfn handle_keepalive(_conn: &amp;mut Connection, thread_name: &amp;str) {\n    log_msg(thread_name, \"Keep alive received\");\n}\n\nfn handle_bye(_conn: &amp;mut Connection, datagram: &amp;[u8], thread_name: &amp;str) {\n    log_msg(thread_name, \"Bye received\");\n    let reason = String::from_utf8_lossy(&amp;datagram[1..]);\n    log_msg(thread_name, &amp;format!(\"Bye reason: {}\", reason));\n}\n\nfn handle_payload_with_identifier(\n    _conn: &amp;mut Connection,\n    datagram: &amp;[u8],\n    payload_received_callback: &amp;dyn Fn(&amp;str, u8, u64, &amp;[u8]),\n    thread_name: &amp;str,\n) {\n    log_msg(thread_name, \"Payload with identifier received\");\n    let identifier = String::from_utf8_lossy(&amp;datagram[1..9]);\n    let payload_type = datagram[9];\n    let origin_timestamp = u64::from_be_bytes([\n        datagram[10], datagram[11], datagram[12], datagram[13],\n        datagram[14], datagram[15], datagram[16], datagram[17],\n    ]);\n    let payload = &amp;datagram[18..];\n\n    log_msg(\n        thread_name,\n        &amp;format!(\n            \"Payload received (identifier: {}, payload_type: {}, origin_timestamp: {}): {}\",\n            identifier,\n            as_hex_stream(&amp;[payload_type]),\n            origin_timestamp,\n            as_hex_stream(payload)\n        ),\n    );\n\n    payload_received_callback(&amp;identifier, payload_type, origin_timestamp, payload);\n}\n\nfn handle_timestamp_request(conn: &amp;mut Connection, datagram: &amp;[u8], thread_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    log_msg(thread_name, \"Timestamp request received\");\n    let timestamp_t0 = u64::from_be_bytes([\n        datagram[1], datagram[2], datagram[3], datagram[4],\n        datagram[5], datagram[6], datagram[7], datagram[8],\n    ]);\n    let timestamp_t1 = current_timestamp();\n    log_msg(thread_name, &amp;format!(\"Timestamp request delta: {}ms\", timestamp_t1 - timestamp_t0));\n    write_timestamp_response(conn, timestamp_t0, timestamp_t1, thread_name)\n}\n\nfn handle_datagram(\n    conn: &amp;mut Connection,\n    datagram: &amp;[u8],\n    payload_received_callback: &amp;dyn Fn(&amp;str, u8, u64, &amp;[u8]),\n    thread_name: &amp;str,\n) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    if datagram.is_empty() {\n        return Ok(());\n    }\n\n    match datagram[0] {\n        0x00 =&gt; handle_keepalive(conn, thread_name),\n        0x02 =&gt; handle_bye(conn, datagram, thread_name),\n        0x05 =&gt; handle_payload_with_identifier(conn, datagram, payload_received_callback, thread_name),\n        0x06 =&gt; handle_timestamp_request(conn, datagram, thread_name)?,\n        _ =&gt; log_msg(thread_name, &amp;format!(\"Unknown/unimplemented datagram type {} received\", as_hex_stream(&amp;[datagram[0]]))),\n    }\n\n    Ok(())\n}\n\nfn run_streaming_client(\n    host: &amp;str,\n    port: u16,\n    session_token: &amp;str,\n    use_tls: bool,\n    payload_received_callback: Box&lt;dyn Fn(&amp;str, u8, u64, &amp;[u8]) + Send&gt;,\n    loop_callback: Box&lt;dyn Fn(&amp;mut Connection) + Send&gt;,\n    thread_name: &amp;str,\n    shutdown_flag: Arc&lt;AtomicBool&gt;,\n) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    let mut conn = connect(host, port, use_tls, thread_name)?;\n\n    handshake(&amp;mut conn, thread_name)?;\n    write_token(&amp;mut conn, session_token, thread_name)?;\n\n    while !shutdown_flag.load(Ordering::Relaxed) {\n        match read_datagram(&amp;mut conn, thread_name)? {\n            Some(datagram) =&gt; {\n                handle_datagram(&amp;mut conn, &amp;datagram, &amp;*payload_received_callback, thread_name)?;\n            }\n            None =&gt; {\n                thread::sleep(Duration::from_millis(10));\n            }\n        }\n\n        loop_callback(&amp;mut conn);\n    }\n\n    log_msg(thread_name, \"Shutdown signal received, terminating\");\n    Ok(())\n}\n</code></pre> <pre><code>public abstract class Connection : IDisposable\n{\n    public abstract int Read(byte[] buffer, int offset, int count);\n    public abstract void Write(byte[] buffer, int offset, int count);\n    public abstract void SetNonBlocking(bool nonBlocking);\n    public abstract void Close();\n    public abstract void Dispose();\n}\n\npublic class PlainConnection : Connection\n{\n    private readonly TcpClient tcpClient;\n    private readonly NetworkStream stream;\n\n    public PlainConnection(TcpClient tcpClient)\n    {\n        this.tcpClient = tcpClient;\n        this.stream = tcpClient.GetStream();\n    }\n\n    public override int Read(byte[] buffer, int offset, int count)\n    {\n        return stream.Read(buffer, offset, count);\n    }\n\n    public override void Write(byte[] buffer, int offset, int count)\n    {\n        stream.Write(buffer, offset, count);\n    }\n\n    public override void SetNonBlocking(bool nonBlocking)\n    {\n        tcpClient.Client.Blocking = !nonBlocking;\n    }\n\n    public override void Close()\n    {\n        stream.Close();\n        tcpClient.Close();\n    }\n\n    public override void Dispose()\n    {\n        stream.Dispose();\n        tcpClient.Dispose();\n    }\n}\n\npublic class TlsConnection : Connection\n{\n    private readonly TcpClient tcpClient;\n    private readonly SslStream sslStream;\n\n    public TlsConnection(TcpClient tcpClient, string targetHost)\n    {\n        this.tcpClient = tcpClient;\n        this.sslStream = new SslStream(tcpClient.GetStream(), false, ValidateServerCertificate);\n        this.sslStream.AuthenticateAsClient(targetHost);\n    }\n\n    private static bool ValidateServerCertificate(object sender, X509Certificate? certificate, X509Chain? chain, SslPolicyErrors sslPolicyErrors)\n    {\n        // In production, implement proper certificate validation\n        return true;\n    }\n\n    public override int Read(byte[] buffer, int offset, int count)\n    {\n        return sslStream.Read(buffer, offset, count);\n    }\n\n    public override void Write(byte[] buffer, int offset, int count)\n    {\n        sslStream.Write(buffer, offset, count);\n    }\n\n    public override void SetNonBlocking(bool nonBlocking)\n    {\n        tcpClient.Client.Blocking = !nonBlocking;\n    }\n\n    public override void Close()\n    {\n        sslStream.Close();\n        tcpClient.Close();\n    }\n\n    public override void Dispose()\n    {\n        sslStream.Dispose();\n        tcpClient.Dispose();\n    }\n}\n\npublic static class TcpStreaming\n{\n    public static Connection Connect(string host, int port, bool useTls, string threadName)\n    {\n        var tcpClient = new TcpClient(host, port);\n\n        if (useTls)\n        {\n            var tlsConnection = new TlsConnection(tcpClient, host);\n            Utilities.LogMessage(threadName, $\"Connected to {host}:{port} (TLS: {useTls})\");\n            Utilities.LogMessage(threadName, \"TLS handshake successful\");\n            return tlsConnection;\n        }\n        else\n        {\n            Utilities.LogMessage(threadName, $\"Connected to {host}:{port} (TLS: {useTls})\");\n            return new PlainConnection(tcpClient);\n        }\n    }\n\n    public static void Handshake(Connection conn, string threadName)\n    {\n        var protocolVersionByte = new byte[] { 0x01 };\n        conn.Write(protocolVersionByte, 0, protocolVersionByte.Length);\n\n        var recv = new byte[1];\n        conn.Read(recv, 0, recv.Length);\n\n        Utilities.LogMessage(threadName, $\"Received protocol version {Utilities.AsHexStream(recv)}\");\n\n        if (recv[0] != 1)\n        {\n            throw new InvalidOperationException(\"Unsupported protocol version received\");\n        }\n    }\n\n    public static void WriteDatagram(Connection conn, byte[] datagram, string threadName)\n    {\n        var header = new List&lt;byte&gt;();\n        header.AddRange(Constants.HeaderPrefix);\n        header.AddRange(BitConverter.GetBytes((ushort)datagram.Length).Reverse()); // Big-endian\n\n        var frame = new List&lt;byte&gt;();\n        frame.AddRange(header);\n        frame.AddRange(datagram);\n\n        var frameArray = frame.ToArray();\n        Utilities.LogMessage(threadName, $\"Writing frame {Utilities.AsHexStream(frameArray)}\");\n\n        conn.Write(frameArray, 0, frameArray.Length);\n    }\n\n    public static void WriteToken(Connection conn, string token, string threadName)\n    {\n        Utilities.LogMessage(threadName, $\"Writing token {token}\");\n        var datagram = new List&lt;byte&gt; { 0x01 };\n        datagram.AddRange(Encoding.UTF8.GetBytes(token));\n        WriteDatagram(conn, datagram.ToArray(), threadName);\n    }\n\n    public static void WriteKeepAlive(Connection conn, string threadName)\n    {\n        Utilities.LogMessage(threadName, \"Writing keep alive\");\n        var datagram = new byte[] { 0x00 };\n        WriteDatagram(conn, datagram, threadName);\n    }\n\n    public static void WriteTimestampResponse(Connection conn, long timestampT0, long timestampT1, string threadName)\n    {\n        var timestampT2 = Utilities.CurrentTimestamp();\n        Utilities.LogMessage(threadName, $\"Writing timestamp response (t0: {timestampT0}, t1: {timestampT1}, t2: {timestampT2})\");\n\n        var datagram = new List&lt;byte&gt; { 0x07 };\n        datagram.AddRange(BitConverter.GetBytes(timestampT0).Reverse()); // Big-endian\n        datagram.AddRange(BitConverter.GetBytes(timestampT1).Reverse());\n        datagram.AddRange(BitConverter.GetBytes(timestampT2).Reverse());\n\n        WriteDatagram(conn, datagram.ToArray(), threadName);\n    }\n\n    public static void WritePayloadWithIdentifier(Connection conn, string identifier, byte payloadType, byte[] payload, string threadName)\n    {\n        Utilities.LogMessage(threadName, \n            $\"Writing payload with identifier (identifier: {identifier}, payload_type: {Utilities.AsHexStream(new[] { payloadType })}): {Utilities.AsHexStream(payload)}\");\n\n        var datagram = new List&lt;byte&gt; { 0x05 };\n        datagram.AddRange(Encoding.UTF8.GetBytes(identifier));\n        datagram.Add(payloadType);\n        datagram.AddRange(BitConverter.GetBytes(Utilities.CurrentTimestamp()).Reverse()); // Big-endian\n        datagram.AddRange(payload);\n\n        WriteDatagram(conn, datagram.ToArray(), threadName);\n    }\n\n    public static byte[]? ReadDatagram(Connection conn, string threadName)\n    {\n        // Set non-blocking mode for header read\n        conn.SetNonBlocking(true);\n\n        var header = new byte[4];\n        int headerBytesRead = 0;\n\n        try\n        {\n            headerBytesRead = conn.Read(header, 0, 4);\n        }\n        catch (SocketException ex) when (ex.SocketErrorCode == SocketError.WouldBlock)\n        {\n            // Socket would block - no data available\n            return null;\n        }\n        catch (IOException ex) when (ex.InnerException is SocketException socketEx &amp;&amp; \n                                     socketEx.SocketErrorCode == SocketError.WouldBlock)\n        {\n            // SSL stream wraps socket exception in IOException\n            return null;\n        }\n\n        if (headerBytesRead == 0)\n        {\n            throw new InvalidOperationException(\"Socket disconnected\");\n        }\n\n        if (headerBytesRead != 4)\n        {\n            throw new InvalidOperationException(\"Received partial header (implementation does not support partial receives yet)\");\n        }\n\n        Utilities.LogMessage(threadName, $\"Received header {Utilities.AsHexStream(header)}\");\n\n        if (!header.Take(2).SequenceEqual(Constants.HeaderPrefix))\n        {\n            throw new InvalidOperationException($\"Framing error: header prefix {Utilities.AsHexStream(header.Take(2).ToArray())} != {Utilities.AsHexStream(Constants.HeaderPrefix)}\");\n        }\n\n        var size = (ushort)((header[2] &lt;&lt; 8) | header[3]); // Big-endian\n        Utilities.LogMessage(threadName, $\"Trying to read {size} bytes datagram\");\n\n        // Set blocking mode for datagram body read (to ensure complete read)\n        conn.SetNonBlocking(false);\n\n        var datagram = new byte[size];\n        var datagramBytesRead = 0;\n        while (datagramBytesRead &lt; size)\n        {\n            var bytesRead = conn.Read(datagram, datagramBytesRead, size - datagramBytesRead);\n            if (bytesRead == 0)\n                throw new InvalidOperationException(\"Socket disconnected\");\n            datagramBytesRead += bytesRead;\n        }\n\n        Utilities.LogMessage(threadName, $\"Received datagram {Utilities.AsHexStream(datagram)}\");\n\n        return datagram;\n    }\n\n    public static void HandleKeepAlive(Connection conn, string threadName)\n    {\n        Utilities.LogMessage(threadName, \"Keep alive received\");\n    }\n\n    public static void HandleBye(Connection conn, byte[] datagram, string threadName)\n    {\n        Utilities.LogMessage(threadName, \"Bye received\");\n        var reason = Encoding.UTF8.GetString(datagram, 1, datagram.Length - 1);\n        Utilities.LogMessage(threadName, $\"Bye reason: {reason}\");\n    }\n\n    public static void HandlePayloadWithIdentifier(Connection conn, byte[] datagram, Action&lt;string, byte, long, byte[]&gt; payloadReceivedCallback, string threadName)\n    {\n        Utilities.LogMessage(threadName, \"Payload with identifier received\");\n        var identifier = Encoding.UTF8.GetString(datagram, 1, 8);\n        var payloadType = datagram[9];\n        var originTimestamp = BitConverter.ToInt64(datagram.Skip(10).Take(8).Reverse().ToArray(), 0);\n        var payload = datagram.Skip(18).ToArray();\n\n        Utilities.LogMessage(threadName, \n            $\"Payload received (identifier: {identifier}, payload_type: {Utilities.AsHexStream(new[] { payloadType })}, origin_timestamp: {originTimestamp}): {Utilities.AsHexStream(payload)}\");\n\n        payloadReceivedCallback(identifier, payloadType, originTimestamp, payload);\n    }\n\n    public static void HandleTimestampRequest(Connection conn, byte[] datagram, string threadName)\n    {\n        Utilities.LogMessage(threadName, \"Timestamp request received\");\n        var timestampT0 = BitConverter.ToInt64(datagram.Skip(1).Take(8).Reverse().ToArray(), 0);\n        var timestampT1 = Utilities.CurrentTimestamp();\n        Utilities.LogMessage(threadName, $\"Timestamp request delta: {timestampT1 - timestampT0}ms\");\n        WriteTimestampResponse(conn, timestampT0, timestampT1, threadName);\n    }\n\n    public static void HandleDatagram(Connection conn, byte[] datagram, Action&lt;string, byte, long, byte[]&gt; payloadReceivedCallback, string threadName)\n    {\n        if (datagram.Length == 0) return;\n\n        switch (datagram[0])\n        {\n            case 0x00:\n                HandleKeepAlive(conn, threadName);\n                break;\n            case 0x02:\n                HandleBye(conn, datagram, threadName);\n                break;\n            case 0x05:\n                HandlePayloadWithIdentifier(conn, datagram, payloadReceivedCallback, threadName);\n                break;\n            case 0x06:\n                HandleTimestampRequest(conn, datagram, threadName);\n                break;\n            default:\n                Utilities.LogMessage(threadName, $\"Unknown/unimplemented datagram type {Utilities.AsHexStream(new[] { datagram[0] })} received\");\n                break;\n        }\n    }\n\n    public static void RunStreamingClient(\n        string host, \n        int port, \n        string sessionToken, \n        bool useTls, \n        Action&lt;string, byte, long, byte[]&gt; payloadReceivedCallback, \n        Action&lt;Connection&gt; loopCallback, \n        string threadName,\n        CancellationToken cancellationToken)\n    {\n        using var conn = Connect(host, port, useTls, threadName);\n\n        Handshake(conn, threadName);\n        WriteToken(conn, sessionToken, threadName);\n\n        while (!cancellationToken.IsCancellationRequested)\n        {\n            var datagram = ReadDatagram(conn, threadName);\n            if (datagram != null)\n            {\n                HandleDatagram(conn, datagram, payloadReceivedCallback, threadName);\n            }\n            else\n            {\n                Thread.Sleep(10);\n            }\n\n            loopCallback(conn);\n        }\n\n        Utilities.LogMessage(threadName, \"Shutdown signal received, terminating\");\n    }\n}\n</code></pre> <p>Explanation</p> PythonGoRust.NET <p>These functions implement the multiplex protocol:</p> <ul> <li><code>connect</code>: Establishes TCP connection with optional TLS</li> <li><code>handshake</code>: Exchanges protocol version</li> <li><code>write_datagram</code>: Sends framed messages with header prefix</li> <li><code>read_datagram</code>: Receives and validates framed messages (non-blocking)</li> <li><code>handle_datagram</code>: Processes different datagram types (keepalive, payload, timestamp, bye)</li> <li><code>run_streaming_client</code>: Main client loop handling connection lifecycle</li> </ul> <p>These functions implement the multiplex protocol:</p> <ul> <li><code>connect</code>: Establishes TCP connection with optional TLS</li> <li><code>handshake</code>: Exchanges protocol version</li> <li><code>writeDatagram</code>: Sends framed messages with header prefix</li> <li><code>readDatagram</code>: Receives and validates framed messages (non-blocking)</li> <li><code>handleDatagram</code>: Processes different datagram types (keepalive, payload, timestamp, bye)</li> <li><code>runStreamingClient</code>: Main client loop handling connection lifecycle</li> </ul> <p>These functions implement the multiplex protocol:</p> <ul> <li><code>connect</code>: Establishes TCP connection with optional TLS</li> <li><code>handshake</code>: Exchanges protocol version</li> <li><code>write_datagram</code>: Sends framed messages with header prefix</li> <li><code>read_datagram</code>: Receives and validates framed messages (non-blocking)</li> <li><code>handle_datagram</code>: Processes different datagram types (keepalive, payload, timestamp, bye)</li> <li><code>run_streaming_client</code>: Main client loop handling connection lifecycle</li> </ul> <p>These functions implement the multiplex protocol:</p> <ul> <li><code>Connect</code>: Establishes TCP connection with optional TLS</li> <li><code>Handshake</code>: Exchanges protocol version</li> <li><code>WriteDatagram</code>: Sends framed messages with header prefix</li> <li><code>ReadDatagram</code>: Receives and validates framed messages (non-blocking)</li> <li><code>HandleDatagram</code>: Processes different datagram types (keepalive, payload, timestamp, bye)</li> <li><code>RunStreamingClient</code>: Main client loop handling connection lifecycle</li> </ul>"},{"location":"examples/#producer","title":"Producer","text":"<p>The producer creates a TLC session and sends data:</p> PythonGoRust.NET <pre><code>def run_producer():\n    # Step 1: Create a session using the REST API\n    host, port, token = create_session(\"TLC\", STREAMING_API_TLC_TOKEN, STREAMING_API_BASEURL, STREAMING_API_SECURITY_MODE, STREAMING_API_IDENTIFIER)\n\n    # Step 2: Connect to the TCP Streaming Node\n    last_write = current_timestamp()\n    def write_callback(sock):\n        nonlocal last_write\n        now = current_timestamp()\n        # Write a random payload every second\n        if now - last_write &gt; 1000:\n            last_write = now\n            write_payload_with_identifier(sock, STREAMING_API_IDENTIFIER, 0x02, os.urandom(100))\n\n    def read_payload_callback(identifier, payload_type, origin_timestamp, payload):\n        log(f\"Producer received payload from {identifier}: type={payload_type:#04x}, timestamp={origin_timestamp}, size={len(payload)}\")\n\n    tls = (STREAMING_API_SECURITY_MODE == SECURITY_MODE_TLS)\n    run_streaming_client(host, port, token, tls, read_payload_callback, write_callback)\n</code></pre> <pre><code>func runProducer(wg *sync.WaitGroup) {\n    defer wg.Done()\n    threadName := \"producer\"\n\n    // Step 1: Create a session using the REST API\n    host, port, token, err := createSession(\"TLC\", STREAMING_API_TLC_TOKEN, STREAMING_API_BASEURL, STREAMING_API_SECURITY_MODE, STREAMING_API_IDENTIFIER, threadName)\n    if err != nil {\n        logMsg(threadName, fmt.Sprintf(\"Failed to create session: %v\", err))\n        return\n    }\n\n    // Step 2: Connect to the TCP Streaming Node\n    lastWrite := currentTimestamp()\n    writeCallback := func(conn net.Conn) {\n        now := currentTimestamp()\n        // Write a random payload every second\n        if now-lastWrite &gt; 1000 {\n            lastWrite = now\n            payload := make([]byte, 100)\n            rand.Read(payload)\n            writePayloadWithIdentifier(conn, STREAMING_API_IDENTIFIER, 0x02, payload, threadName)\n        }\n    }\n\n    readPayloadCallback := func(identifier string, payloadType byte, originTimestamp int64, payload []byte) {\n        logMsg(threadName, fmt.Sprintf(\"Producer received payload from %s: type=%#04x, timestamp=%d, size=%d\", \n            identifier, payloadType, originTimestamp, len(payload)))\n    }\n\n    useTLS := (STREAMING_API_SECURITY_MODE == SECURITY_MODE_TLS)\n    if err := runStreamingClient(host, port, token, useTLS, readPayloadCallback, writeCallback, threadName); err != nil {\n        logMsg(threadName, fmt.Sprintf(\"Streaming client error: %v\", err))\n    }\n}\n</code></pre> <pre><code>fn run_producer(shutdown_flag: Arc&lt;AtomicBool&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    let thread_name = \"producer\";\n\n    // Step 1: Create a session using the REST API\n    let rt = tokio::runtime::Runtime::new()?;\n    let (host, port, token) = rt.block_on(create_session(\n        \"TLC\",\n        &amp;STREAMING_API_TLC_TOKEN,\n        &amp;STREAMING_API_BASEURL,\n        &amp;STREAMING_API_SECURITY_MODE,\n        &amp;STREAMING_API_IDENTIFIER,\n        thread_name,\n    ))?;\n\n    // Step 2: Connect to the TCP Streaming Node\n    let last_write = Arc::new(Mutex::new(current_timestamp()));\n    let identifier = STREAMING_API_IDENTIFIER.clone();\n\n    let last_write_clone = last_write.clone();\n    let write_callback = Box::new(move |conn: &amp;mut Connection| {\n        let mut last_write_guard = last_write_clone.lock().unwrap();\n        let now = current_timestamp();\n        // Write a random payload every second\n        if now - *last_write_guard &gt; 1000 {\n            *last_write_guard = now;\n            let mut payload = vec![0u8; 100];\n            rand::thread_rng().fill_bytes(&amp;mut payload);\n            let _ = write_payload_with_identifier(conn, &amp;identifier, 0x02, &amp;payload, thread_name);\n        }\n    });\n\n    let read_payload_callback = Box::new(move |identifier: &amp;str, payload_type: u8, origin_timestamp: u64, payload: &amp;[u8]| {\n        log_msg(\n            thread_name,\n            &amp;format!(\n                \"Producer received payload from {}: type={:#04x}, timestamp={}, size={}\",\n                identifier, payload_type, origin_timestamp, payload.len()\n            ),\n        );\n    });\n\n    let use_tls = *STREAMING_API_SECURITY_MODE == SECURITY_MODE_TLS;\n    run_streaming_client(&amp;host, port, &amp;token, use_tls, read_payload_callback, write_callback, thread_name, shutdown_flag)?;\n\n    Ok(())\n}\n</code></pre> <pre><code>public static class Producer\n{\n    public static async Task RunAsync(CancellationToken cancellationToken)\n    {\n        const string threadName = \"producer\";\n\n        try\n        {\n            // Step 1: Create a session using the REST API\n            var (host, port, token) = await RestApi.CreateSessionAsync(\n                \"TLC\",\n                Config.StreamingApiTlcToken,\n                Config.StreamingApiBaseUrl,\n                Config.StreamingApiSecurityMode,\n                Config.StreamingApiIdentifier,\n                threadName);\n\n            // Step 2: Connect to the TCP Streaming Node\n            var lastWrite = Utilities.CurrentTimestamp();\n            var identifier = Config.StreamingApiIdentifier;\n\n            void WriteCallback(Connection conn)\n            {\n                var now = Utilities.CurrentTimestamp();\n                // Write a random payload every second\n                if (now - lastWrite &gt; 1000)\n                {\n                    lastWrite = now;\n                    var payload = new byte[100];\n                    RandomNumberGenerator.Fill(payload);\n                    TcpStreaming.WritePayloadWithIdentifier(conn, identifier, 0x02, payload, threadName);\n                }\n            }\n\n            void ReadPayloadCallback(string identifier, byte payloadType, long originTimestamp, byte[] payload)\n            {\n                Utilities.LogMessage(threadName,\n                    $\"Producer received payload from {identifier}: type=0x{payloadType:X2}, timestamp={originTimestamp}, size={payload.Length}\");\n            }\n\n            var useTls = Config.StreamingApiSecurityMode == Constants.SecurityModeTls;\n            TcpStreaming.RunStreamingClient(host, port, token, useTls, ReadPayloadCallback, WriteCallback, threadName, cancellationToken);\n        }\n        catch (Exception ex)\n        {\n            Utilities.LogMessage(threadName, $\"Producer error: {ex.Message}\");\n        }\n    }\n}\n</code></pre> <p>Explanation</p> <p>The producer:</p> <ol> <li>Creates a TLC session via REST API</li> <li>Connects to the TCP streaming endpoint</li> <li>Sends random payload data every second with the configured identifier</li> <li>Can receive data from other sessions (bi-directional capability)</li> </ol>"},{"location":"examples/#consumer","title":"Consumer","text":"<p>The consumer creates a Broker session and receives data:</p> PythonGoRust.NET <pre><code>def run_consumer():\n    # Step 1: Create a session using the REST API\n    host, port, token = create_session(\"Broker\", STREAMING_API_BROKER_TOKEN, STREAMING_API_BASEURL, STREAMING_API_SECURITY_MODE, STREAMING_API_IDENTIFIER)\n\n    # Step 2: Connect to the TCP Streaming Node\n    last_write = current_timestamp()\n    def write_callback(sock):\n        nonlocal last_write\n        now = current_timestamp()\n        # Write a keepalive every 5 seconds\n        if now - last_write &gt; 5000:\n            last_write = now\n            write_keepalive(sock)\n\n    def read_payload_callback(identifier, payload_type, origin_timestamp, payload):\n        latency = current_timestamp() - origin_timestamp\n        log(f\"Consumer received payload from {identifier}: type={payload_type:#04x}, timestamp={origin_timestamp}, latency={latency}ms, size={len(payload)}\")\n\n    tls = (STREAMING_API_SECURITY_MODE == SECURITY_MODE_TLS)\n    run_streaming_client(host, port, token, tls, read_payload_callback, write_callback)\n</code></pre> <pre><code>func runConsumer(wg *sync.WaitGroup) {\n    defer wg.Done()\n    threadName := \"consumer\"\n\n    // Step 1: Create a session using the REST API\n    host, port, token, err := createSession(\"Broker\", STREAMING_API_BROKER_TOKEN, STREAMING_API_BASEURL, STREAMING_API_SECURITY_MODE, STREAMING_API_IDENTIFIER, threadName)\n    if err != nil {\n        logMsg(threadName, fmt.Sprintf(\"Failed to create session: %v\", err))\n        return\n    }\n\n    // Step 2: Connect to the TCP Streaming Node\n    lastWrite := currentTimestamp()\n    writeCallback := func(conn net.Conn) {\n        now := currentTimestamp()\n        // Write a keepalive every 5 seconds\n        if now-lastWrite &gt; 5000 {\n            lastWrite = now\n            writeKeepalive(conn, threadName)\n        }\n    }\n\n    readPayloadCallback := func(identifier string, payloadType byte, originTimestamp int64, payload []byte) {\n        latency := currentTimestamp() - originTimestamp\n        logMsg(threadName, fmt.Sprintf(\"Consumer received payload from %s: type=%#04x, timestamp=%d, latency=%dms, size=%d\", \n            identifier, payloadType, originTimestamp, latency, len(payload)))\n    }\n\n    useTLS := (STREAMING_API_SECURITY_MODE == SECURITY_MODE_TLS)\n    if err := runStreamingClient(host, port, token, useTLS, readPayloadCallback, writeCallback, threadName); err != nil {\n        logMsg(threadName, fmt.Sprintf(\"Streaming client error: %v\", err))\n    }\n}\n</code></pre> <pre><code>fn run_consumer(shutdown_flag: Arc&lt;AtomicBool&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    let thread_name = \"consumer\";\n\n    // Step 1: Create a session using the REST API\n    let rt = tokio::runtime::Runtime::new()?;\n    let (host, port, token) = rt.block_on(create_session(\n        \"Broker\",\n        &amp;STREAMING_API_BROKER_TOKEN,\n        &amp;STREAMING_API_BASEURL,\n        &amp;STREAMING_API_SECURITY_MODE,\n        &amp;STREAMING_API_IDENTIFIER,\n        thread_name,\n    ))?;\n\n    // Step 2: Connect to the TCP Streaming Node\n    let last_write = Arc::new(Mutex::new(current_timestamp()));\n\n    let last_write_clone = last_write.clone();\n    let write_callback = Box::new(move |conn: &amp;mut Connection| {\n        let mut last_write_guard = last_write_clone.lock().unwrap();\n        let now = current_timestamp();\n        // Write a keepalive every 5 seconds\n        if now - *last_write_guard &gt; 5000 {\n            *last_write_guard = now;\n            let _ = write_keepalive(conn, thread_name);\n        }\n    });\n\n    let read_payload_callback = Box::new(move |identifier: &amp;str, payload_type: u8, origin_timestamp: u64, payload: &amp;[u8]| {\n        let latency = current_timestamp() - origin_timestamp;\n        log_msg(\n            thread_name,\n            &amp;format!(\n                \"Consumer received payload from {}: type={:#04x}, timestamp={}, latency={}ms, size={}\",\n                identifier, payload_type, origin_timestamp, latency, payload.len()\n            ),\n        );\n    });\n\n    let use_tls = *STREAMING_API_SECURITY_MODE == SECURITY_MODE_TLS;\n    run_streaming_client(&amp;host, port, &amp;token, use_tls, read_payload_callback, write_callback, thread_name, shutdown_flag)?;\n\n    Ok(())\n}\n</code></pre> <pre><code>public static class Consumer\n{\n    public static async Task RunAsync(CancellationToken cancellationToken)\n    {\n        const string threadName = \"consumer\";\n\n        try\n        {\n            // Step 1: Create a session using the REST API\n            var (host, port, token) = await RestApi.CreateSessionAsync(\n                \"Broker\",\n                Config.StreamingApiBrokerToken,\n                Config.StreamingApiBaseUrl,\n                Config.StreamingApiSecurityMode,\n                Config.StreamingApiIdentifier,\n                threadName);\n\n            // Step 2: Connect to the TCP Streaming Node\n            var lastWrite = Utilities.CurrentTimestamp();\n\n            void WriteCallback(Connection conn)\n            {\n                var now = Utilities.CurrentTimestamp();\n                // Write a keepalive every 5 seconds\n                if (now - lastWrite &gt; 5000)\n                {\n                    lastWrite = now;\n                    TcpStreaming.WriteKeepAlive(conn, threadName);\n                }\n            }\n\n            void ReadPayloadCallback(string identifier, byte payloadType, long originTimestamp, byte[] payload)\n            {\n                var latency = Utilities.CurrentTimestamp() - originTimestamp;\n                Utilities.LogMessage(threadName,\n                    $\"Consumer received payload from {identifier}: type=0x{payloadType:X2}, timestamp={originTimestamp}, latency={latency}ms, size={payload.Length}\");\n            }\n\n            var useTls = Config.StreamingApiSecurityMode == Constants.SecurityModeTls;\n            TcpStreaming.RunStreamingClient(host, port, token, useTls, ReadPayloadCallback, WriteCallback, threadName, cancellationToken);\n        }\n        catch (Exception ex)\n        {\n            Utilities.LogMessage(threadName, $\"Consumer error: {ex.Message}\");\n        }\n    }\n}\n</code></pre> <p>Explanation</p> <p>The consumer:</p> <ol> <li>Creates a Broker session via REST API</li> <li>Connects to the TCP streaming endpoint</li> <li>Receives payload data from producers and calculates latency</li> <li>Sends keepalive messages every 5 seconds to maintain the connection</li> </ol>"},{"location":"examples/#running-the-example","title":"Running the Example","text":"<p>The complete example runs both producer and consumer threads concurrently:</p> PythonGoRust.NET <pre><code>def dump_config():\n    logging.info(f\"STREAMING_API_BASEURL: '{STREAMING_API_BASEURL}'\")\n    logging.info(f\"STREAMING_API_TLC_TOKEN: '{STREAMING_API_TLC_TOKEN}'\")\n    logging.info(f\"STREAMING_API_BROKER_TOKEN: '{STREAMING_API_BROKER_TOKEN}'\")\n    logging.info(f\"STREAMING_API_DOMAIN: '{STREAMING_API_DOMAIN}'\")\n    logging.info(f\"STREAMING_API_SECURITY_MODE: '{STREAMING_API_SECURITY_MODE}'\")\n\n\ndef configure_logging():\n    logging.basicConfig(format=\"%(asctime)s %(levelname)s %(message)s\", level=logging.DEBUG)\n    logging.getLogger(\"proton\").setLevel(logging.INFO)\n\n\nif __name__ == \"__main__\":\n    configure_logging()\n    dump_config()\n\n    producer_thread = threading.Thread(target=run_producer, name=\"producer\")\n    consumer_thread = threading.Thread(target=run_consumer, name=\"consumer\")\n\n    producer_thread.start()\n    consumer_thread.start()\n\n    producer_thread.join()\n    consumer_thread.join()\n</code></pre> <pre><code>func dumpConfig() {\n    log.Printf(\"STREAMING_API_BASEURL: '%s'\", STREAMING_API_BASEURL)\n    log.Printf(\"STREAMING_API_TLC_TOKEN: '%s'\", STREAMING_API_TLC_TOKEN)\n    log.Printf(\"STREAMING_API_BROKER_TOKEN: '%s'\", STREAMING_API_BROKER_TOKEN)\n    log.Printf(\"STREAMING_API_DOMAIN: '%s'\", STREAMING_API_DOMAIN)\n    log.Printf(\"STREAMING_API_SECURITY_MODE: '%s'\", STREAMING_API_SECURITY_MODE)\n}\n\nfunc configureLogging() {\n    log.SetFlags(log.LstdFlags)\n}\n\nfunc main() {\n    configureLogging()\n    dumpConfig()\n\n    var wg sync.WaitGroup\n\n    wg.Add(2)\n    go runProducer(&amp;wg)\n    go runConsumer(&amp;wg)\n\n    wg.Wait()\n}\n</code></pre> <pre><code>fn dump_config() {\n    log::info!(\"STREAMING_API_BASEURL: '{}'\", *STREAMING_API_BASEURL);\n    log::info!(\"STREAMING_API_TLC_TOKEN: '{}'\", *STREAMING_API_TLC_TOKEN);\n    log::info!(\"STREAMING_API_BROKER_TOKEN: '{}'\", *STREAMING_API_BROKER_TOKEN);\n    log::info!(\"STREAMING_API_DOMAIN: '{}'\", *STREAMING_API_DOMAIN);\n    log::info!(\"STREAMING_API_SECURITY_MODE: '{}'\", *STREAMING_API_SECURITY_MODE);\n}\n\nfn configure_logging() {\n    env_logger::init();\n}\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n    configure_logging();\n    dump_config();\n\n    let shutdown_flag = Arc::new(AtomicBool::new(false));\n\n    // Set up CTRL-C signal handler\n    let shutdown_flag_signal = shutdown_flag.clone();\n    ctrlc::set_handler(move || {\n        log::info!(\"Received CTRL-C signal, shutting down...\");\n        shutdown_flag_signal.store(true, Ordering::Relaxed);\n    }).expect(\"Error setting Ctrl-C handler\");\n\n    let shutdown_flag_producer = shutdown_flag.clone();\n    let producer_handle = thread::spawn(|| {\n        if let Err(e) = run_producer(shutdown_flag_producer) {\n            log::error!(\"Producer error: {}\", e);\n        }\n    });\n\n    let shutdown_flag_consumer = shutdown_flag.clone();\n    let consumer_handle = thread::spawn(|| {\n        if let Err(e) = run_consumer(shutdown_flag_consumer) {\n            log::error!(\"Consumer error: {}\", e);\n        }\n    });\n\n    producer_handle.join().map_err(|_| \"Producer thread panicked\")?;\n    consumer_handle.join().map_err(|_| \"Consumer thread panicked\")?;\n\n    log::info!(\"Application terminated gracefully\");\n    Ok(())\n}\n</code></pre> <pre><code>public static class Program\n{\n    public static void DumpConfig()\n    {\n        Console.WriteLine($\"STREAMING_API_BASEURL: '{Config.StreamingApiBaseUrl}'\");\n        Console.WriteLine($\"STREAMING_API_TLC_TOKEN: '{Config.StreamingApiTlcToken}'\");\n        Console.WriteLine($\"STREAMING_API_BROKER_TOKEN: '{Config.StreamingApiBrokerToken}'\");\n        Console.WriteLine($\"STREAMING_API_DOMAIN: '{Config.StreamingApiDomain}'\");\n        Console.WriteLine($\"STREAMING_API_SECURITY_MODE: '{Config.StreamingApiSecurityMode}'\");\n    }\n\n    public static async Task Main(string[] args)\n    {\n        DumpConfig();\n\n        var cancellationTokenSource = new CancellationTokenSource();\n\n        // Set up CTRL-C signal handler\n        Console.CancelKeyPress += (sender, e) =&gt;\n        {\n            Console.WriteLine(\"Received CTRL-C signal, shutting down...\");\n            e.Cancel = true;\n            cancellationTokenSource.Cancel();\n        };\n\n        var producerTask = Task.Run(() =&gt; Producer.RunAsync(cancellationTokenSource.Token));\n        var consumerTask = Task.Run(() =&gt; Consumer.RunAsync(cancellationTokenSource.Token));\n\n        await Task.WhenAll(producerTask, consumerTask);\n\n        Console.WriteLine(\"Application terminated gracefully\");\n    }\n}\n</code></pre>"},{"location":"examples/#full-example","title":"Full Example","text":"Language Location Description Python examples/multiplex/python Complete multiplex implementation with producer and consumer Go examples/multiplex/go Complete multiplex implementation with producer and consumer Rust examples/multiplex/rust Complete multiplex implementation with producer and consumer .NET examples/multiplex/dotnet Complete multiplex implementation with producer and consumer"},{"location":"examples/#related-documentation","title":"Related Documentation","text":"<p>This example demonstrates both layers of the Subject Interface v1 architecture:</p>"},{"location":"examples/#rest-api-documentation","title":"REST API Documentation","text":"<ul> <li>API Endpoints Reference - Creating and managing streaming sessions</li> <li>OpenAPI specification - Complete REST API endpoint documentation</li> </ul>"},{"location":"examples/#tcp-streaming-protocol-documentation","title":"TCP Streaming Protocol Documentation","text":"<ul> <li>Communication Modes - Singleplex vs Multiplex, session types</li> <li>Datagram Types - Message formats and protocol details</li> <li>Protocol Overview - Complete protocol documentation</li> </ul>"},{"location":"introduction/communication-patterns/","title":"Communication Patterns","text":"<p>The Subject Interface supports two primary communication patterns that accommodate different C-ITS deployment scenarios and system topologies.</p>"},{"location":"introduction/communication-patterns/#roadside-to-central-communication","title":"Roadside to Central Communication","text":"<p>Direct communication between roadside infrastructure and central management systems forms the foundation of C-ITS deployments. This pattern supports bidirectional data exchange between field devices and central operations centers.</p> Direction Examples Roadside \u2192 Central Signal states, detection data, sensor measurements, operational status Central \u2192 Roadside Commands, timing updates, configuration changes, operational parameters"},{"location":"introduction/communication-patterns/#central-to-central-communication","title":"Central to Central Communication","text":"<p>Communication between central systems, service providers, and management platforms supports data sharing and coordination across organizational boundaries.</p> Scenario Examples Service Provider Integration Data feeds for navigation, routing, and traveler information services Multi-jurisdictional Coordination Cross-boundary traffic management, incident coordination System-to-System Integration Data exchange with external systems and platforms for visualization, data collection, analysis, etc..."},{"location":"introduction/communication-patterns/#communication-characteristics","title":"Communication Characteristics","text":"<p>Both patterns support:</p> <ul> <li>Continuous bidirectional streaming</li> <li>Multiple concurrent connections</li> <li>Role-based access control</li> <li>Configurable security modes</li> <li>Message-agnostic payloads</li> </ul>"},{"location":"introduction/communication-patterns/#application-domains","title":"Application Domains","text":"<p>The communication patterns support various C-ITS applications, for example:</p> Domain Use Cases Traffic Management Signal optimization, incident response, transit priority Safety Applications Collision avoidance, vulnerable user protection, emergency preemption Mobility Services Green Light Optimal Speed Advisory (GLOSA), traffic information, route optimization Infrastructure Integration Smart city platforms, environmental monitoring, emergency coordination"},{"location":"tcp-streaming-protocol/","title":"TCP Streaming Protocol","text":"<p>The TCP Streaming Protocol is the high-performance data exchange layer of the Subject Interface. It provides continuous asynchronous bidirectional streaming of datagrams between C-ITS participants. This chapter provides technical specifications for implementing and utilizing the TCP streaming protocol.</p> <p>TLC Terminology</p> <p>The interface originally served Traffic Light Controllers (TLCs), and this legacy terminology persists in the API specifications for backward compatibility. \"TLC\" now refers to any connected entity: traffic controllers, sensors, barriers, displays, or any C-ITS participant. See Terminology Reference for the mapping between legacy and generic terminology.</p>"},{"location":"tcp-streaming-protocol/#protocol-overview","title":"Protocol Overview","text":"Feature Description Ultra-low Latency Optimized communication for real-time C-ITS operations Continuous Bidirectional Asynchronous data streams in both directions Message-agnostic Handles any payload type without protocol restrictions Time Synchronization Built-in clock synchronization and drift monitoring Optional TLS Configurable encryption for secure communications"},{"location":"tcp-streaming-protocol/#chapter-contents","title":"Chapter Contents","text":"<ul> <li>Protocol Fundamentals - Core protocol specifications and encoding</li> <li>Communication Modes - Session types and connection patterns</li> <li>Datagram Types - Detailed datagram format specifications</li> <li>Connection Management - Lifecycle and monitoring procedures</li> <li>Protocol Enforcement - Rate limiting, throughput control, timeout and clock sync enforcement</li> </ul>"},{"location":"tcp-streaming-protocol/#key-features","title":"Key Features","text":"Category Capabilities Performance Real-time data exchange; minimal overhead; efficient frame structure; high-frequency updates Reliability Automatic reconnection; time sync monitoring; connection health tracking; graceful error handling Flexibility Singleplex/multiplex modes; variable payload sizes; version negotiation; security mode selection"},{"location":"tcp-streaming-protocol/#implementation-requirements","title":"Implementation Requirements","text":"Requirement Details System Prerequisites Synchronized clocks (NTP/GPS); TCP/IP connectivity; sufficient bandwidth; low-latency paths Protocol Compliance Protocol version 0x01; all mandatory datagrams; time synchronization; connection lifecycle"},{"location":"tcp-streaming-protocol/communication-modes/","title":"Communication Modes","text":"<p>The TCP Streaming Protocol supports communication modes for different C-ITS participant roles and operational requirements. This section covers protocol variants and session type characteristics.</p>"},{"location":"tcp-streaming-protocol/communication-modes/#singleplex-vs-multiplex","title":"Singleplex vs Multiplex","text":"<p>The TCP Streaming Protocol provides two fundamental variants that determine how TLC identifiers are handled within sessions.</p> Aspect Singleplex (TCPStreaming_Singleplex) Multiplex (TCPStreaming_Multiplex) Characteristics Single TLC identifier per session; implicit identifier; optimized format; lower overhead Multiple TLC identifiers per session; explicit identifier in payload; tagged format; efficient multi-entity Payload Datagram Payload without TLC Identifier (0x04) Payload with TLC Identifier (0x05) Use Cases Individual TLCs; single sensors; point-to-point; resource-constrained devices Central management; broker operations; multi-device monitoring; aggregation points Benefits Reduced overhead (8 bytes saved); simpler implementation; lower bandwidth; exclusive access Single connection for multiple entities; reduced connection overhead; simplified management; dynamic TLC handling Validation N/A (implicit identifier) Must match session scope; invalid IDs dropped; no error response; logged for diagnostics"},{"location":"tcp-streaming-protocol/communication-modes/#session-types","title":"Session Types","text":"<p>The Subject Interface defines three session types, each tailored for specific roles within the C-ITS ecosystem.</p>"},{"location":"tcp-streaming-protocol/communication-modes/#data-flow-architecture","title":"Data Flow Architecture","text":"Aspect TLC (subject) Sessions Broker Sessions Monitor Sessions Role Data owner for specific identifier Data hub for multiple identifiers System observer for analytics Concurrency One active session per identifier (exclusive) Multiple sessions allowed (one per Account) Multiple sessions allowed (one per Account) Data Flow Send to all Brokers in scope; receive from all Brokers Fan-in from TLC (subject); fan-out to TLC (subject) Receive-only from TLC (subject) and Brokers Protocol Support Singleplex or Multiplex Multiplex only Multiplex only Typical Use Case Road side systems / devices, Central data publishers Service Providers, Central C-ITS systems Analytics dashboard or compliance monitoring"},{"location":"tcp-streaming-protocol/communication-modes/#security-modes","title":"Security Modes","text":"<p>Security mode is configured when requesting a streaming session through the <code>POST /sessions</code> endpoint. The mode is specified in the session request payload and determines whether the resulting TCP connection uses TLS (Transport Layer Security).</p> Aspect NONE TLSv1.2 Description Plain TCP communication without encryption Encrypted communication using TLS v1.2 Use Cases Development environments; isolated networks; performance-critical applications Production deployments; public networks; sensitive data transmission; compliance requirements"},{"location":"tcp-streaming-protocol/connection-management/","title":"Connection Management","text":"<p>Connection management within the TCP Streaming Protocol covers the lifecycle of streaming sessions, from initial establishment through active monitoring to graceful termination. This section details the procedures, requirements, and best practices for managing TCP streaming connections.</p>"},{"location":"tcp-streaming-protocol/connection-management/#connection-establishment-process","title":"Connection Establishment Process","text":""},{"location":"tcp-streaming-protocol/connection-management/#prerequisites","title":"Prerequisites","text":"Requirement Details Session Creation Valid session via JSON-REST API; session type/protocol specified; token generated Service Assignment Streaming Node assigned; connection details provided; network route verified Authentication Valid session token; corresponds to active session; proper permissions Network Connectivity TCP/IP connectivity; sufficient bandwidth; low-latency path preferred"},{"location":"tcp-streaming-protocol/connection-management/#establishment-sequence","title":"Establishment Sequence","text":"<p>The connection establishment follows a structured four-phase process:</p> <p></p> Phase Steps Details 0. Session Creation API request; service assignment; token generation Create session via JSON-REST API; specify type/protocol; receive connection details and token 1. TCP Connection Connection initiation; TLS handshake (if enabled); validation Standard TCP handshake; optional TLS with <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>; verify establishment 2. Protocol Negotiation Version exchange; validation; confirmation Client sends version <code>0x01</code>; service validates; connection closed if unsupported 3. Authentication Token transmission; validation; result Client sends Token datagram; service validates against database; failure = immediate termination 4. Operational Readiness Active state; time sync; keep-alive Enable bidirectional exchange; connection health monitoring"},{"location":"tcp-streaming-protocol/connection-management/#error-handling-during-establishment","title":"Error Handling During Establishment","text":"Error Type Common Issues Network TCP timeout/retry; connection refused; network unreachable; DNS resolution failures TLS Handshake failures; cipher negotiation; timeout; trust chain validation Protocol Unsupported version; invalid format; version timeout; no response Authentication Invalid/expired tokens; session not found; insufficient permissions"},{"location":"tcp-streaming-protocol/connection-management/#active-connection-monitoring","title":"Active Connection Monitoring","text":""},{"location":"tcp-streaming-protocol/connection-management/#time-synchronization-monitoring","title":"Time Synchronization Monitoring","text":"Aspect Details Process Regular timestamp requests (configurable interval); mandatory client response; four-timestamp calculation; 1-minute average trending Threshold Automatic termination if average exceeds deployment threshold; no warnings; immediate closure. See Clock Sync Enforcement Requirements NTP stratum 1/GPS synchronized clocks; consistent time source; \u00b11ms accuracy Metrics Roundtrip time; clock stability; response reliability; network jitter; connection quality"},{"location":"tcp-streaming-protocol/connection-management/#connection-lifecycle-management","title":"Connection Lifecycle Management","text":""},{"location":"tcp-streaming-protocol/connection-management/#session-state-management","title":"Session State Management","text":"<p>Streaming connections progress through well-defined states during their operational lifecycle.</p>"},{"location":"tcp-streaming-protocol/connection-management/#connection-states","title":"Connection States","text":"State Description Establishing TCP connection and protocol negotiation; version exchange; handshake procedures Authenticating Token validation; authorization verification; permission validation Active Full operational state; payload streaming enabled; time sync monitoring active Monitored Violation Enforcement thresholds exceeded; automatic termination; see Protocol Enforcement Terminating Graceful shutdown; final data transmission; resource cleanup Terminated Connection closed; resources released; session marked complete"},{"location":"tcp-streaming-protocol/connection-management/#state-transitions","title":"State Transitions","text":"<p>Normal Flow: <code>Establishing \u2192 Authenticating \u2192 Active \u2192 Terminating \u2192 Terminated</code></p> <p>Error Conditions: <code>Any State \u2192 Terminating \u2192 Terminated</code></p> <p>Enforcement Violations: <code>Active \u2192 Monitored Violation \u2192 Terminating \u2192 Terminated</code></p> <p>For detailed enforcement mechanisms, see Protocol Enforcement.</p>"},{"location":"tcp-streaming-protocol/connection-management/#operational-considerations","title":"Operational Considerations","text":"Aspect Details Payload Queuing Queue management during establishment; backpressure handling; priority traffic management; buffer overflow prevention Resource Management Connection allocation; memory buffers; network sockets; cleanup procedures"},{"location":"tcp-streaming-protocol/connection-management/#connection-termination-procedures","title":"Connection Termination Procedures","text":""},{"location":"tcp-streaming-protocol/connection-management/#graceful-termination-process","title":"Graceful Termination Process","text":"Initiator Steps Client Complete pending payloads; send Bye datagram (0x02) with optional reason; close TCP; cleanup resources Service Send Bye datagram with reason (maintenance/violation/error); close TCP; mark terminated; release resources; log event"},{"location":"tcp-streaming-protocol/connection-management/#reconnection-instructions","title":"Reconnection Instructions","text":"Step Action Service Sends Reconnect datagram (0x03) Client Response Immediate connection closure; create new session via API; connect to new node Session Recreation New session requested; potentially different node; resume operations"},{"location":"tcp-streaming-protocol/connection-management/#forced-termination-scenarios","title":"Forced Termination Scenarios","text":"Scenario Cause Action Authentication Invalid/expired tokens Immediate closure; no Bye datagram; client creates new session Protocol Violations Wrong datagram types; invalid frames Immediate closure; diagnostic logging Enforcement Violations Rate limits, throughput limits, timeout violations, clock sync failures Automatic termination; no warnings. See Protocol Enforcement System Maintenance Load balancing; node maintenance; updates Service-initiated reconnection"},{"location":"tcp-streaming-protocol/connection-management/#best-practices","title":"Best Practices","text":"Category Guidelines Graceful Shutdowns Use Bye datagrams; meaningful disconnect reasons; complete transmission; proper cleanup Reconnection Logic Robust mechanisms; handle service reconnects; exponential backoff; circuit breaker patterns Error Handling Handle all phases; graceful degradation; proper logging; user notifications Monitoring Health integration; automated alerting; trend analysis; capacity planning Maintenance Planned coordination; zero-downtime updates; connection migration; SLA compliance Troubleshooting Diagnostic logging; performance collection; error correlation; root cause analysis"},{"location":"tcp-streaming-protocol/datagram-types/","title":"Datagram Types","text":"<p>The TCP Streaming Protocol defines datagram types to support different communication requirements. Each datagram type serves specific purposes within the streaming protocol, from basic connection management to payload transmission and system monitoring.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#datagram-structure-overview","title":"Datagram Structure Overview","text":"<p>All datagrams follow a consistent structure with frame headers and type-specific content.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#frame-header-structure","title":"Frame Header Structure","text":"<pre><code>+------------------+------------------+----------------------+\n| Fixed Prefix     | Data Size        | Datagram Content     |\n| 0xAA 0xBB        | 2 bytes          | Variable Size        |\n| (big-endian)     | (big-endian)     | (Type + Data)        |\n+------------------+------------------+----------------------+\n</code></pre>"},{"location":"tcp-streaming-protocol/datagram-types/#datagram-type-identification","title":"Datagram Type Identification","text":"Type Hex Value Name Purpose KeepAlive <code>0x00</code> Keep connection alive Prevents timeout during low activity Token <code>0x01</code> Authentication token Session authentication after connect Bye <code>0x02</code> Disconnect message Graceful connection termination Reconnect <code>0x03</code> Reconnect instruction Service-initiated reconnection Payload (no ID) <code>0x04</code> Singleplex payload Optimized for single TLC sessions Payload (with ID) <code>0x05</code> Multiplex payload Tagged for multiplex/broker sessions Timestamps Request <code>0x06</code> Time sync request Initiates clock synchronization Timestamps Response <code>0x07</code> Time sync response Returns timing information Monitor Payload <code>0xF0</code> Enhanced monitoring Payload with diagnostic metadata"},{"location":"tcp-streaming-protocol/datagram-types/#connection-management-datagrams","title":"Connection Management Datagrams","text":"<p>These datagrams handle connection lifecycle and maintenance operations.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#keepalive-datagram-0x00","title":"KeepAlive Datagram (0x00)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose","title":"Purpose","text":"<p>Prevents connection timeouts during periods of low data activity.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format","title":"Format","text":"<pre><code>+---------------+\n| Datagram Type |\n| 0x00          |\n+---------------+\n</code></pre> Characteristic Details Usage Timeout prevention; bidirectional; minimal overhead; automatic generation Timeout Threshold Session details from Create Session API response contain timeout threshold; send KeepAlive well before timeout if no other data transmitted Implementation Send before timeout thresholds; consider traffic patterns; balance frequency with bandwidth"},{"location":"tcp-streaming-protocol/datagram-types/#token-datagram-0x01","title":"Token Datagram (0x01)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose_1","title":"Purpose","text":"<p>Provides session authentication immediately after connection establishment.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format_1","title":"Format","text":"<pre><code>+---------------+---------------------------+\n| Datagram Type | Token (ASCII encoded)     |\n| 0x01          | Variable Length           |\n+---------------+---------------------------+\n</code></pre> Aspect Details Usage First datagram after version; service validates against database; invalid tokens terminate connection Security Sensitive credentials; transmit after TLS; validation failure = immediate termination; no retry mechanism Encoding ASCII character encoding"},{"location":"tcp-streaming-protocol/datagram-types/#example","title":"Example","text":"<pre><code>Token: dtNB_vhvJ0wgTGf1N0DxN38_AmTL_4yiPRZdqZSuK3k\nEncoded as ASCII bytes in datagram\n</code></pre>"},{"location":"tcp-streaming-protocol/datagram-types/#bye-datagram-0x02","title":"Bye Datagram (0x02)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose_2","title":"Purpose","text":"<p>Graceful connection termination with optional reason indication.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format_2","title":"Format","text":"<pre><code>+---------------+---------------------------------------+\n| Datagram Type | Disconnect Reason (ASCII, optional)   |\n| 0x02          | Variable Length                       |\n+---------------+---------------------------------------+\n</code></pre> Aspect Details Usage Graceful termination; bidirectional; final datagram; optional reason provides diagnostics Common Reasons Normal shutdown, system maintenance, authentication failure, protocol violation, time sync failure"},{"location":"tcp-streaming-protocol/datagram-types/#reconnect-datagram-0x03","title":"Reconnect Datagram (0x03)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose_3","title":"Purpose","text":"<p>Instructs client to reconnect as soon as possible.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format_3","title":"Format","text":"<pre><code>+---------------+\n| Datagram Type |\n| 0x03          |\n+---------------+\n</code></pre>"},{"location":"tcp-streaming-protocol/datagram-types/#usage-characteristics","title":"Usage Characteristics","text":"<ul> <li>Service-Initiated - Only sent by Streaming Service</li> <li>Immediate Action - Client should reconnect ASAP</li> <li>Session Recreation - New session must be created via API</li> <li>Load Balancing - Enables maintenance and redistribution</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#client-response-requirements","title":"Client Response Requirements","text":"<ol> <li>Close existing connection immediately</li> <li>Create new session using JSON-REST API</li> <li>Establish new TCP connection (possibly different node)</li> <li>Resume operations with new session</li> </ol>"},{"location":"tcp-streaming-protocol/datagram-types/#payload-datagrams","title":"Payload Datagrams","text":"<p>These datagrams carry actual data between C-ITS participants.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#payload-without-tlc-identifier-0x04","title":"Payload without TLC Identifier (0x04)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose_4","title":"Purpose","text":"<p>Optimized payload transmission for Singleplex mode operations.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format_4","title":"Format","text":"<pre><code>+---------------+---------------+------------------+-------------+\n| Datagram Type | Payload Type  | Origin Timestamp | Payload     |\n| 0x04          | 1 byte        | 8 bytes          | Variable    |\n+---------------+---------------+------------------+-------------+\n</code></pre>"},{"location":"tcp-streaming-protocol/datagram-types/#field-specifications","title":"Field Specifications","text":"Field Size Description Payload Type 1 byte Identifies payload content type; application-specific values; no protocol interpretation; used for routing and processing decisions Origin Timestamp 8 bytes UTC milliseconds since epoch; big-endian 64-bit integer; payload creation time (not transmission time); must use same clock as time synchronization Payload Variable Actual message content; maximum 65535 bytes total frame size; no protocol-level interpretation; binary or text data supported"},{"location":"tcp-streaming-protocol/datagram-types/#usage-restrictions","title":"Usage Restrictions","text":"<ul> <li>Singleplex Only - Cannot be used in multiplex sessions</li> <li>Protocol Enforcement - Wrong usage terminates session</li> <li>Implicit Identifier - TLC ID from session configuration</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#example-payload-types","title":"Example Payload Types","text":"<ul> <li><code>0x01</code> - Traffic signal state</li> <li><code>0x02</code> - Detector data</li> <li><code>0x03</code> - Emergency vehicle detection</li> <li><code>0xFF</code> - Custom application data</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#payload-with-tlc-identifier-0x05","title":"Payload with TLC Identifier (0x05)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose_5","title":"Purpose","text":"<p>Identifier-tagged payload transmission for multiplex and broker operations.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format_5","title":"Format","text":"<pre><code>+---------------+----------------+---------------+------------------+-------------+\n| Datagram Type | TLC Identifier | Payload Type  | Origin Timestamp | Payload     |\n| 0x05          | 8 bytes        | 1 byte        | 8 bytes          | Variable    |\n+---------------+----------------+---------------+------------------+-------------+\n</code></pre>"},{"location":"tcp-streaming-protocol/datagram-types/#field-specifications_1","title":"Field Specifications","text":"Field Size Description TLC Identifier 8 bytes ASCII-encoded identifier; specifies payload source/destination; must match session scope; padded with nulls if shorter than 8 chars Payload Type 1 byte Same as type 0x04: identifies payload content type; application-specific values; no protocol interpretation Origin Timestamp 8 bytes Same as type 0x04: UTC milliseconds since epoch; big-endian 64-bit integer; payload creation time Payload Variable Same as type 0x04: actual message content; maximum total frame size; no protocol-level interpretation"},{"location":"tcp-streaming-protocol/datagram-types/#usage-requirements","title":"Usage Requirements","text":"<ul> <li>Multiplex and Broker Only - Required for these session types</li> <li>Identifier Validation - Must match session scope</li> <li>Explicit Routing - Enables routing within multiplex sessions</li> <li>Scope Enforcement - Invalid identifiers dropped</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#identifier-management","title":"Identifier Management","text":"<ul> <li>ASCII encoding required</li> <li>Maximum 8 bytes length</li> <li>Case sensitive</li> <li>Null padding for shorter identifiers</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#time-synchronization-datagrams","title":"Time Synchronization Datagrams","text":"<p>These datagrams implement the mandatory time synchronization system.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#timestamps-request-0x06","title":"Timestamps Request (0x06)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose_6","title":"Purpose","text":"<p>Initiates time synchronization measurement for clock difference detection.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format_6","title":"Format","text":"<pre><code>+---------------+---------------------------+\n| Datagram Type | t0: Transmission Timestamp|\n| 0x06          | 8 bytes                   |\n+---------------+---------------------------+\n</code></pre>"},{"location":"tcp-streaming-protocol/datagram-types/#usage-characteristics_1","title":"Usage Characteristics","text":"<ul> <li>Service-Initiated - Sent by Streaming Service only</li> <li>Regular Interval - Configurable interval determined by Streaming Service deployment</li> <li>Clock Measurement - Enables roundtrip and drift calculation</li> <li>Mandatory Response - Client must respond immediately</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#field-specifications_2","title":"Field Specifications","text":"Field Size Description t0: Transmission Timestamp 8 bytes UTC milliseconds when request sent; big-endian 64-bit integer; obtained as close to transmission as possible; used for clock difference calculation"},{"location":"tcp-streaming-protocol/datagram-types/#timestamps-response-0x07","title":"Timestamps Response (0x07)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose_7","title":"Purpose","text":"<p>Responds to time synchronization requests with precise timing information.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format_7","title":"Format","text":"<pre><code>+---------------+-------------+-------------+-------------+\n| Datagram Type | t0: Original| t1: Receipt | t2: Response|\n| 0x07          | Timestamp   | Timestamp   | Timestamp   |\n|               | 8 bytes     | 8 bytes     | 8 bytes     |\n+---------------+-------------+-------------+-------------+\n</code></pre>"},{"location":"tcp-streaming-protocol/datagram-types/#field-specifications_3","title":"Field Specifications","text":"Field Size Description t0: Original Timestamp 8 bytes Copy from the request datagram; unchanged from received value; enables service to match request/response t1: Reception Timestamp 8 bytes When request was received; determined as early as possible upon reception; same clock source as payload timestamps t2: Response Timestamp 8 bytes When response is sent; determined as late as possible in transmission; immediate priority over other traffic"},{"location":"tcp-streaming-protocol/datagram-types/#processing-requirements","title":"Processing Requirements","text":"<ul> <li>Priority Handling - Prioritize over other traffic</li> <li>Minimal Delay - Send immediately after request</li> <li>Accurate Timestamps - Use consistent clock source</li> <li>No Queuing - Process immediately</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#clock-difference-calculation","title":"Clock Difference Calculation","text":"<p>Service calculates using all four timestamps:</p> <ul> <li>Roundtrip Time: <code>(t3 - t0) - (t2 - t1)</code></li> <li>Clock Difference: <code>((t1 - t0) + (t2 - t3)) / 2</code></li> <li>Where t3 is response reception time at service</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#special-monitoring-payloads","title":"Special Monitoring Payloads","text":""},{"location":"tcp-streaming-protocol/datagram-types/#monitor-payload-encoding-0xf0","title":"Monitor Payload Encoding (0xF0)","text":""},{"location":"tcp-streaming-protocol/datagram-types/#purpose_8","title":"Purpose","text":"<p>Enhanced payload format with diagnostic metadata for monitoring and analytics.</p>"},{"location":"tcp-streaming-protocol/datagram-types/#format_8","title":"Format","text":"<pre><code>+---------------------+-----------+----------+----------+----------+----------+\n| Publisher Token Len | Publisher | Publish  | Sent     | Original | Original |\n| 4 bytes             | Token     | Time     | Time     | Type     | Payload  |\n|                     | Variable  | 8 bytes  | 8 bytes  | 1 byte   | Variable |\n+---------------------+-----------+----------+----------+----------+----------+\n</code></pre>"},{"location":"tcp-streaming-protocol/datagram-types/#field-specifications_4","title":"Field Specifications","text":"Field Size Description Publisher Token Length 4 bytes Big-endian 32-bit integer; length of publisher token field; can be zero for resent payloads Publisher Token Variable ASCII-encoded session token; identifies original publisher; empty for system-generated payloads Publishing Timestamp 8 bytes When payload was originally published; UTC milliseconds; from original publisher Sent Timestamp 8 bytes When service sent to monitor; UTC milliseconds; service clock time Original Type 1 byte Original payload type before encapsulation; either 0x04 or 0x05 Original Payload Variable Complete original payload content; unchanged from source"},{"location":"tcp-streaming-protocol/datagram-types/#usage-characteristics_2","title":"Usage Characteristics","text":"<ul> <li>Monitor Sessions Only - Primarily for monitoring</li> <li>Diagnostic Enhancement - Additional metadata</li> <li>Publisher Tracking - Source identification</li> <li>Audit Trail - Complete payload history</li> </ul>"},{"location":"tcp-streaming-protocol/datagram-types/#implementation-guidelines","title":"Implementation Guidelines","text":"Category Guidelines Processing Validate type first; check frame size; handle unknown types gracefully; log violations Error Handling Discard invalid frames; log unknown types; size mismatches terminate connection Performance Optimize for payload datagrams; pre-allocate buffers; minimize copies; efficient timestamps Security Validate input lengths; sanitize content; protect against overflows; log suspicious patterns"},{"location":"tcp-streaming-protocol/protocol-enforcement/","title":"Protocol Enforcement","text":"<p>TCP Streaming Protocol sessions operate under strict enforcement policies to ensure optimal performance, resource management, and system stability. When sessions are created, the server provides enforcement parameters that clients must respect. Violations result in immediate connection termination without warning.</p> <p>Critical Implementation Requirement</p> <p>All enforcement limits are mandatory. Clients exceeding any threshold will have their connection terminated immediately. There are no warnings or grace periods.</p>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#enforcement-overview","title":"Enforcement Overview","text":"<p>All enforcement violations result in immediate connection termination without warning.</p> Enforcement Type Purpose Mechanism Example Payload Rate Limiting Prevent message flooding Sliding window average of payload messages per second Max 12 messages/second over 5s window Throughput Limiting Manage bandwidth consumption Sliding window average of payload bytes per second Max 60 bytes/second over 5s window Connection Timeout Detect connectivity issues Maximum idle time without receiving any datagrams Disconnect after 10s of no activity Clock Synchronization Time accuracy requirements Sliding window average of absolute clock differences Max 3s average deviation over 1m window"},{"location":"tcp-streaming-protocol/protocol-enforcement/#payload-rate-limiting","title":"Payload Rate Limiting","text":""},{"location":"tcp-streaming-protocol/protocol-enforcement/#mechanism","title":"Mechanism","text":"<p>Payload rate limiting controls the frequency of payload messages (datagram types 0x04 and 0x05) that clients can transmit.</p> Parameter Description Source PayloadRateLimit Maximum payload messages per second Session response PayloadRateLimitDuration Sliding window duration for rate calculation Session response"},{"location":"tcp-streaming-protocol/protocol-enforcement/#enforcement-algorithm","title":"Enforcement Algorithm","text":"<pre><code>Current Rate = Total Payload Messages / PayloadRateLimitDuration (sliding window)\n\nIF Current Rate &gt; PayloadRateLimit THEN\n    Terminate Connection Immediately\nEND IF\n</code></pre>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#implementation-details","title":"Implementation Details","text":"Aspect Details Calculation Method Sliding window average over specified duration Message Types Payload datagrams only (0x04, 0x05); excludes keep-alive, time sync Window Behavior Continuous sliding window; not fixed time buckets Precision Sub-second precision; calculated per datagram transmission"},{"location":"tcp-streaming-protocol/protocol-enforcement/#example-scenario","title":"Example Scenario","text":"<pre><code>PayloadRateLimit: 12 messages/second\nPayloadRateLimitDuration: PT5S (5 seconds)\n\nSliding Window Enforcement:\n- At time T: Client has sent 60 messages in past 5 seconds\n- Current rate: 60 messages \u00f7 5 seconds = 12 messages/second \u2713 ALLOWED\n- At time T+1: Client sends 1 more message (61 total in 5-second window)  \n- New rate: 61 messages \u00f7 5 seconds = 12.2 messages/second \u2717 VIOLATION\n- Result: Connection terminated immediately\n</code></pre>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#throughput-limiting","title":"Throughput Limiting","text":""},{"location":"tcp-streaming-protocol/protocol-enforcement/#mechanism_1","title":"Mechanism","text":"<p>Throughput limiting controls the bandwidth consumption of payload data transmitted by clients.</p> Parameter Description Source PayloadThroughputLimit Maximum payload bytes per second Session response PayloadThroughputLimitDuration Sliding window duration for throughput calculation Session response"},{"location":"tcp-streaming-protocol/protocol-enforcement/#enforcement-algorithm_1","title":"Enforcement Algorithm","text":"<pre><code>Current Throughput = Total Payload Bytes / PayloadThroughputLimitDuration (sliding window)\n\nIF Current Throughput &gt; PayloadThroughputLimit THEN\n    Terminate Connection Immediately  \nEND IF\n</code></pre>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#implementation-details_1","title":"Implementation Details","text":"Aspect Details Byte Calculation Payload data only; excludes frame headers, datagram type bytes Message Types Payload datagrams only (0x04, 0x05); excludes protocol overhead Window Behavior Continuous sliding window; recalculated per transmission Precision Byte-level accuracy; real-time monitoring"},{"location":"tcp-streaming-protocol/protocol-enforcement/#example-scenario_1","title":"Example Scenario","text":"<pre><code>PayloadThroughputLimit: 60 bytes/second\nPayloadThroughputLimitDuration: PT5S (5 seconds)\n\nSliding Window Enforcement:\n- At time T: Client has sent 300 bytes in past 5 seconds\n- Current rate: 300 bytes \u00f7 5 seconds = 60 bytes/second \u2713 ALLOWED\n- At time T+1: Client sends 10-byte message (310 total in 5-second window)\n- New rate: 310 bytes \u00f7 5 seconds = 62 bytes/second \u2717 VIOLATION  \n- Result: Connection terminated immediately\n</code></pre>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#connection-timeout-enforcement","title":"Connection Timeout Enforcement","text":""},{"location":"tcp-streaming-protocol/protocol-enforcement/#mechanism_2","title":"Mechanism","text":"<p>Connection timeout enforcement automatically terminates idle connections to conserve server resources.</p> Parameter Description Source KeepAliveTimeout Maximum duration without receiving any datagrams Session response"},{"location":"tcp-streaming-protocol/protocol-enforcement/#enforcement-algorithm_2","title":"Enforcement Algorithm","text":"<pre><code>Time Since Last Datagram = Current Time - Last Received Datagram Time\n\nIF Time Since Last Datagram &gt; KeepAliveTimeout THEN\n    Terminate Connection Immediately\nEND IF\n</code></pre>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#implementation-details_2","title":"Implementation Details","text":"Aspect Details Monitoring Scope Any datagram type; includes keep-alive, payloads, time sync responses Timer Reset Every received datagram resets the timeout timer Precision Sub-second precision; continuous monitoring Client Responsibility Send keep-alive datagrams (0x00) to prevent timeout"},{"location":"tcp-streaming-protocol/protocol-enforcement/#example-scenario_2","title":"Example Scenario","text":"<pre><code>KeepAliveTimeout: PT10S (10 seconds)\n\nTimeline:\n- T+0s: Client sends payload datagram (timer resets)\n- T+5s: No activity \n- T+10s: Timeout threshold reached\n- T+10.001s: Connection terminated by server\n- T+15s: Client attempts to send data \u2192 connection already closed\n\nPrevention:\n- T+8s: Client sends keep-alive datagram (0x00) \u2192 timer resets\n- T+18s: Still connected, no timeout\n</code></pre>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#clock-synchronization-enforcement","title":"Clock Synchronization Enforcement","text":""},{"location":"tcp-streaming-protocol/protocol-enforcement/#mechanism_3","title":"Mechanism","text":"<p>Clock synchronization enforcement ensures time accuracy by monitoring clock differences between client and server.</p> Parameter Description Source ClockDiffLimit Maximum allowed average absolute clock deviation Session response ClockDiffLimitDuration Sliding window for calculating clock difference average Session response"},{"location":"tcp-streaming-protocol/protocol-enforcement/#enforcement-algorithm_3","title":"Enforcement Algorithm","text":"<pre><code>FOR each TimeSync measurement:\n    Clock Difference = |Client Clock - Server Clock|\n    Add to sliding window over ClockDiffLimitDuration\n\nAverage Clock Diff = Average(All measurements in sliding window)\n\nIF Average Clock Diff &gt; ClockDiffLimit THEN\n    Terminate Connection Immediately\nEND IF\n</code></pre>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#implementation-details_3","title":"Implementation Details","text":"Aspect Details Measurement Trigger Server-initiated TimeSync requests (0x06) Calculation Method Absolute difference; sliding window average Window Behavior All measurements within duration window Client Requirement Must respond to TimeSync requests with accurate timestamps"},{"location":"tcp-streaming-protocol/protocol-enforcement/#example-scenario_3","title":"Example Scenario","text":"<pre><code>ClockDiffLimit: PT3S (3 seconds average deviation)\nClockDiffLimitDuration: PT1M (1 minute sliding window)\n\nMeasurements over 1 minute:\n- Measurement 1: 2s clock diff \u2713\n- Measurement 2: 1s clock diff \u2713  \n- Measurement 3: 5s clock diff \u2713 (individual high, but average still OK)\n- Measurement 4: 4s clock diff\n- Average: (2+1+5+4)/4 = 3s \u2713 ALLOWED\n\n- Measurement 5: 6s clock diff  \n- New Average: (1+5+4+6)/4 = 4s \u2717 VIOLATION\n- Result: Connection terminated immediately\n</code></pre>"},{"location":"tcp-streaming-protocol/protocol-enforcement/#sliding-window-implementation","title":"Sliding Window Implementation","text":""},{"location":"tcp-streaming-protocol/protocol-enforcement/#algorithm-characteristics","title":"Algorithm Characteristics","text":"<p>All enforcement mechanisms except connection timeout use sliding window algorithms for fair and accurate monitoring.</p> Aspect Implementation Window Type Continuous sliding window (not fixed buckets) Update Frequency Recalculated on every relevant event Data Retention All events within window duration Calculation Real-time average of events in current window"},{"location":"tcp-streaming-protocol/protocol-enforcement/#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"tcp-streaming-protocol/protocol-enforcement/#client-design-patterns","title":"Client Design Patterns","text":"Pattern Purpose Implementation Rate Governor Prevent payload rate violations Queue messages; enforce transmission rate; respect limits Throughput Monitor Track bandwidth usage Monitor payload bytes; implement backpressure; throttle transmission Keep-Alive Manager Prevent connection timeouts Send periodic keep-alive datagrams; track last activity Time Sync Handler Maintain clock synchronization Respond to TimeSync requests; maintain accurate clocks <p>For session creation and parameter retrieval, see API Endpoints Reference.</p>"},{"location":"tcp-streaming-protocol/protocol-fundamentals/","title":"Protocol Fundamentals","text":"<p>The TCP Streaming Protocol serves as the foundation for ultra-low latency, high-volume data exchange within the Subject Interface ecosystem. This section covers the core protocol specifications including version management, data encoding, and security options.</p>"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#protocol-overview","title":"Protocol Overview","text":"<p>The TCP Streaming Protocol provides continuous asynchronous bidirectional stream of datagrams between connected parties. Unlike traditional request-response patterns, this protocol maintains persistent connections optimized for real-time data exchange scenarios common in transportation systems.</p>"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#protocol-flow-overview","title":"Protocol Flow Overview","text":""},{"location":"tcp-streaming-protocol/protocol-fundamentals/#core-protocol-characteristics","title":"Core Protocol Characteristics","text":"Characteristic Description Persistent Connections Long-lived TCP connections; eliminates overhead; supports continuous operation; automatic keep-alive Asynchronous Communication Independent bidirectional flow; no request-response coupling; parallel processing; queue-based transmission Message-Agnostic Design Handles any payload type; no inspection/validation; supports binary/text/structured data; single byte type identifier Frame-Based Structure Structured frames with integrity checking; fixed header; variable payload; boundary detection Built-in Monitoring Connection health monitoring; time sync verification; performance metrics; automatic violation detection"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#protocol-version-management","title":"Protocol Version Management","text":""},{"location":"tcp-streaming-protocol/protocol-fundamentals/#current-protocol-version","title":"Current Protocol Version","text":"Aspect Details Version <code>0x01</code> (single-byte identifier) Exchange During connection establishment Support Only supported version currently"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#version-compatibility","title":"Version Compatibility","text":"Aspect Details Current Support Version <code>0x01</code> only Future Versions Incremental numbering; backward compatibility evaluation Negotiation May be enhanced in future protocols"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#byte-order-and-data-encoding","title":"Byte Order and Data Encoding","text":""},{"location":"tcp-streaming-protocol/protocol-fundamentals/#byte-order","title":"Byte Order","text":"Aspect Details Order Big-endian (network byte order) throughout Application All multi-byte fields; MSB transmitted first Standards Consistent with network protocols; no byte order marks"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#encoding-standards","title":"Encoding Standards","text":"Data Type Encoding Details Text Data ASCII Tokens, identifiers, disconnect reasons; no null termination; length by frame size Timestamps UTC milliseconds since epoch 8 bytes (64-bit); big-endian integer Numeric Fields Big-endian Unsigned integers; size as specified; no padding Binary Payloads Pass-through No encoding; application-specific"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#frame-structure","title":"Frame Structure","text":"<pre><code>+------------------+------------------+----------------------+\n| Fixed Prefix     | Data Size        | Datagram Content     |\n| 0xAA 0xBB        | 2 bytes          | Variable Size        |\n| (2 bytes)        | (big-endian)     | (0-65535 bytes)      |\n+------------------+------------------+----------------------+\n</code></pre> Component Details Fixed Prefix <code>0xAA 0xBB</code> - frame synchronization; start of every frame; loss of frame sync terminates connection Data Size 2 bytes big-endian; 0-65535 range; datagram content size only (excludes Fixed Prefix and Data Size fields) Datagram Content Variable size; datagram type byte + data; length must match size field"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#transport-layer-security","title":"Transport Layer Security","text":""},{"location":"tcp-streaming-protocol/protocol-fundamentals/#security-mode-options","title":"Security Mode Options","text":"<p>The protocol supports two security modes:</p> Mode Description Performance Use Cases NONE Plain TCP without encryption Optimal, no overhead Isolated networks, development, non-sensitive data, legacy systems TLSv1.2 Encrypted using TLS 1.2 Additional latency and CPU usage Production, public networks, sensitive data, compliance"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#tls-configuration","title":"TLS Configuration","text":"Component Details TLS Version TLS v1.2 exclusively; SSL/TLS v1.0/v1.1 prohibited; TLS v1.3 not supported Cipher Suite <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code> only; ECDHE key exchange; AES-128-GCM; SHA-256 Authentication Standard TLS handshake; no client certificates; session auth via tokens"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#connection-establishment","title":"Connection Establishment","text":"<p>All communication patterns follow a consistent connection establishment sequence regardless of session type or protocol variant.</p>"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#connection-establishment-sequence","title":"Connection Establishment Sequence","text":"Step Process 1. API Session Creation Create session via JSON-REST API; specify type/protocol; receive connection details and token 2. TCP Connection Establish TCP to assigned Streaming Node; use host:port from session details 3. Protocol Version Exchange Client sends version <code>0x01</code>; service validates and responds; connection closed if mismatch 4. Token Authentication Client sends Token datagram; contains session token; service validates against active sessions 5. Operational State Enter active streaming; enable bidirectional exchange; begin time sync monitoring"},{"location":"tcp-streaming-protocol/protocol-fundamentals/#connection-requirements","title":"Connection Requirements","text":"Category Requirements Prerequisites Valid session via JSON-REST API; network connectivity; synchronized clock; valid token Protocol Support Version <code>0x01</code>; mandatory datagram types; time sync response; frame parsing/generation Security TLS support if enabled; encryption capability; cipher suite support; token security"}]}